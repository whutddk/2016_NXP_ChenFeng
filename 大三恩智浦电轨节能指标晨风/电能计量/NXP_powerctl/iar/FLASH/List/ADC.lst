###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        14/Aug/2016  11:03:48
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\app\BSP\ADC.c
#    Command line =  
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\app\BSP\ADC.c
#        -D LPLD_K60 -lCN
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\FLASH\List\
#        -lB
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\FLASH\List\
#        -o
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\FLASH\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\app\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\app\BSP\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\app\ITAC\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\app\CTL\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\CPU\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\common\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\LPLD\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\LPLD\HW\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\FatFs\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\FatFs\option\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\USB\common\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\USB\driver\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\USB\descriptor\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\USB\class\
#        -On -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\FLASH\List\ADC.lst
#    Object file  =  
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\FLASH\Obj\ADC.o
#
###############################################################################

C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\app\BSP\ADC.c
      1          #include "include.h"
      2          

   \                                 In section .bss, align 4
      3          ADC_InitTypeDef adc_init_struct;
   \                     adc_init_struct:
   \   00000000                      DS8 20
      4          

   \                                 In section .text, align 2, keep-with-next
      5          void adc_init(void)
      6          {
   \                     adc_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
      7            //配置ADC采样参数
      8            adc_init_struct.ADC_Adcx = ADC0;
   \   00000002   0x....             LDR.N    R0,??DataTable1  ;; 0x4003b000
   \   00000004   0x....             LDR.N    R1,??DataTable1_1
   \   00000006   0x6008             STR      R0,[R1, #+0]
      9            adc_init_struct.ADC_DiffMode = ADC_SE;        //单端采集
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             LDR.N    R1,??DataTable1_1
   \   0000000C   0x7108             STRB     R0,[R1, #+4]
     10            adc_init_struct.ADC_BitMode = SE_16BIT;       //单端8位精度
   \   0000000E   0x2003             MOVS     R0,#+3
   \   00000010   0x....             LDR.N    R1,??DataTable1_1
   \   00000012   0x7148             STRB     R0,[R1, #+5]
     11            adc_init_struct.ADC_SampleTimeCfg = SAMTIME_LONG;    //长采样时间
   \   00000014   0x2010             MOVS     R0,#+16
   \   00000016   0x....             LDR.N    R1,??DataTable1_1
   \   00000018   0x7188             STRB     R0,[R1, #+6]
     12            adc_init_struct.ADC_LongSampleTimeSel = LSAMTIME_12EX;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x....             LDR.N    R1,??DataTable1_1
   \   0000001E   0x71C8             STRB     R0,[R1, #+7]
     13            adc_init_struct.ADC_HwAvgSel = HW_32AVG;       //4次硬件平均
   \   00000020   0x2007             MOVS     R0,#+7
   \   00000022   0x....             LDR.N    R1,??DataTable1_1
   \   00000024   0x7208             STRB     R0,[R1, #+8]
     14            adc_init_struct.ADC_CalEnable = TRUE; //使能初始化校验
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x....             LDR.N    R1,??DataTable1_1
   \   0000002A   0x72C8             STRB     R0,[R1, #+11]
     15            //初始化ADC
     16            LPLD_ADC_Init(adc_init_struct);
   \   0000002C   0x....             LDR.N    R1,??DataTable1_1
   \   0000002E   0xB084             SUB      SP,SP,#+16
   \   00000030   0x4668             MOV      R0,SP
   \   00000032   0x2214             MOVS     R2,#+20
   \   00000034   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000038   0xBC0F             POP      {R0-R3}
   \   0000003A   0x.... 0x....      BL       LPLD_ADC_Init
     17            //为了保证复用功能不被占用，最好使能相应ADC通道
     18            //RUSH开发板的电位器使用DAD1通道进行采集
     19            //单端DAD1通道的引脚为(ADC0_DP1)
     20            LPLD_ADC_Chn_Enable(ADC0, AD8); 
   \   0000003E   0x2108             MOVS     R1,#+8
   \   00000040   0x....             LDR.N    R0,??DataTable1  ;; 0x4003b000
   \   00000042   0x.... 0x....      BL       LPLD_ADC_Chn_Enable
     21          }
   \   00000046   0xBD01             POP      {R0,PC}          ;; return
     22          

   \                                 In section .text, align 2, keep-with-next
     23          void get_offset()
     24          {
   \                     get_offset: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     25            uint16 i = 0;
   \   00000002   0x2400             MOVS     R4,#+0
     26            
     27            relay_OFF();
   \   00000004   0x.... 0x....      BL       relay_OFF
     28            
     29            ctl.current_offset = LPLD_ADC_Get(ADC0, AD8);
   \   00000008   0x2108             MOVS     R1,#+8
   \   0000000A   0x....             LDR.N    R0,??DataTable1  ;; 0x4003b000
   \   0000000C   0x.... 0x....      BL       LPLD_ADC_Get
   \   00000010   0x....             LDR.N    R1,??DataTable1_2
   \   00000012   0x6088             STR      R0,[R1, #+8]
     30            LPLD_LPTMR_DelayMs(2);
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0x.... 0x....      BL       LPLD_LPTMR_DelayMs
     31            for ( i = 0;i < 2000; i++)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x0004             MOVS     R4,R0
   \                     ??get_offset_0: (+1)
   \   0000001E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000020   0xF5B4 0x6FFA      CMP      R4,#+2000
   \   00000024   0xDA13             BGE.N    ??get_offset_1
     32            {
     33              ctl.current_offset += LPLD_ADC_Get(ADC0, AD8);
   \   00000026   0x2108             MOVS     R1,#+8
   \   00000028   0x....             LDR.N    R0,??DataTable1  ;; 0x4003b000
   \   0000002A   0x.... 0x....      BL       LPLD_ADC_Get
   \   0000002E   0x....             LDR.N    R1,??DataTable1_2
   \   00000030   0x6889             LDR      R1,[R1, #+8]
   \   00000032   0xFA11 0xF080      UXTAH    R0,R1,R0
   \   00000036   0x....             LDR.N    R1,??DataTable1_2
   \   00000038   0x6088             STR      R0,[R1, #+8]
     34              ctl.current_offset /= 2;
   \   0000003A   0x....             LDR.N    R0,??DataTable1_2
   \   0000003C   0x6880             LDR      R0,[R0, #+8]
   \   0000003E   0x0840             LSRS     R0,R0,#+1
   \   00000040   0x....             LDR.N    R1,??DataTable1_2
   \   00000042   0x6088             STR      R0,[R1, #+8]
     35              LPLD_LPTMR_DelayMs(2);
   \   00000044   0x2002             MOVS     R0,#+2
   \   00000046   0x.... 0x....      BL       LPLD_LPTMR_DelayMs
     36            }
   \   0000004A   0x1C64             ADDS     R4,R4,#+1
   \   0000004C   0xE7E7             B.N      ??get_offset_0
     37          }
   \                     ??get_offset_1: (+1)
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x4003B000         DC32     0x4003b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     adc_init_struct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     ctl

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   adc_init
         8   -> LPLD_ADC_Chn_Enable
         8   -> LPLD_ADC_Init
        24   -> __aeabi_memcpy4
       8   get_offset
         8   -> LPLD_ADC_Get
         8   -> LPLD_LPTMR_DelayMs
         8   -> relay_OFF


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
      72  adc_init
      20  adc_init_struct
      80  get_offset

 
  20 bytes in section .bss
 164 bytes in section .text
 
 164 bytes of CODE memory
  20 bytes of DATA memory

Errors: none
Warnings: none
