###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        28/Jul/2016  17:58:35
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\lib\LPLD\HW\HW_GPIO.c
#    Command line =  
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\lib\LPLD\HW\HW_GPIO.c -D
#        LPLD_K60 -lCN
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\FLASH\List\
#        -lB
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\FLASH\List\
#        -o
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\FLASH\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\app\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\app\BSP\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\app\ITAC\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\app\CTL\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\CPU\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\common\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\LPLD\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\LPLD\HW\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\FatFs\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\FatFs\option\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\USB\common\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\USB\driver\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\USB\descriptor\
#        -I
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\..\..\..\lib\USB\class\
#        -On -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\FLASH\List\HW_GPIO.lst
#    Object file  =  
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\project\NXP_powerctl\iar\FLASH\Obj\HW_GPIO.o
#
###############################################################################

C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\lib\LPLD\HW\HW_GPIO.c
      1          /**
      2           * @file HW_GPIO.c
      3           * @version 3.03[By LPLD]
      4           * @date 2014-2-10
      5           * @brief GPIO底层模块相关函数
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * 版权所有:北京拉普兰德电子技术有限公司
     10           * http://www.lpld.cn
     11           * mail:support@lpld.cn
     12           *
     13           * @par
     14           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     15           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     16           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     17           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     18           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     19           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     20           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     21           */
     22          #include "common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR.N    R2,??DataTable9  ;; 0xe000e100
   \   0000000A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000C   0x0943             LSRS     R3,R0,#+5
   \   0000000E   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR.N    R2,??DataTable9_1  ;; 0xe000e180
   \   0000000A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000C   0x0943             LSRS     R3,R0,#+5
   \   0000000E   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return
     23          #include "HW_GPIO.h"
     24          
     25          
     26          //用户自定义中断服务函数数组

   \                                 In section .bss, align 4
     27          GPIO_ISR_CALLBACK GPIO_ISR[5];
   \                     GPIO_ISR:
   \   00000000                      DS8 20
     28          
     29          /*
     30           * LPLD_GPIO_Init
     31           * GPIO通用初始化函数
     32           * 
     33           * 参数:
     34           *    gpio_init_structure--GPIO初始化结构体，
     35           *                        具体定义见GPIO_InitTypeDef
     36           *
     37           * 输出:
     38           *    0--配置错误
     39           *    1--配置成功
     40           */

   \                                 In section .text, align 2, keep-with-next
     41          uint8 LPLD_GPIO_Init(GPIO_InitTypeDef gpio_init_structure)
     42          {
   \                     LPLD_GPIO_Init: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
     43            uint8 i;
     44            PORT_Type *portx;
     45            uint32 pcr = PORT_PCR_MUX(1)| gpio_init_structure.GPIO_PinControl; 
   \   00000006   0x980C             LDR      R0,[SP, #+48]
   \   00000008   0xF450 0x7680      ORRS     R6,R0,#0x100
     46            GPIO_Type *ptx = gpio_init_structure.GPIO_PTx;
   \   0000000C   0x9F0A             LDR      R7,[SP, #+40]
     47            uint32 pins = gpio_init_structure.GPIO_Pins;
   \   0000000E   0xF8DD 0x802C      LDR      R8,[SP, #+44]
     48            uint8 dir = gpio_init_structure.GPIO_Dir;
   \   00000012   0xF89D 0x9034      LDRB     R9,[SP, #+52]
     49            uint8 output = gpio_init_structure.GPIO_Output;
   \   00000016   0xF89D 0xA035      LDRB     R10,[SP, #+53]
     50            GPIO_ISR_CALLBACK isr_func = gpio_init_structure.GPIO_Isr;
   \   0000001A   0xF8DD 0xB038      LDR      R11,[SP, #+56]
     51            
     52            //参数检查
     53            ASSERT( ptx <= PTE);                  //判断端口
   \   0000001E   0x....             LDR.N    R0,??DataTable9_2  ;; 0x400ff101
   \   00000020   0x4287             CMP      R7,R0
   \   00000022   0xD303             BCC.N    ??LPLD_GPIO_Init_0
   \   00000024   0x2135             MOVS     R1,#+53
   \   00000026   0x....             LDR.N    R0,??DataTable9_3
   \   00000028   0x.... 0x....      BL       assert_failed
     54            ASSERT( dir <= 1 );                   //判断方向
   \                     ??LPLD_GPIO_Init_0: (+1)
   \   0000002C   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000030   0xF1B9 0x0F02      CMP      R9,#+2
   \   00000034   0xDB03             BLT.N    ??LPLD_GPIO_Init_1
   \   00000036   0x2136             MOVS     R1,#+54
   \   00000038   0x....             LDR.N    R0,??DataTable9_3
   \   0000003A   0x.... 0x....      BL       assert_failed
     55            ASSERT( output <= 1 );                //判断输出电平状态
   \                     ??LPLD_GPIO_Init_1: (+1)
   \   0000003E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000042   0xF1BA 0x0F02      CMP      R10,#+2
   \   00000046   0xDB03             BLT.N    ??LPLD_GPIO_Init_2
   \   00000048   0x2137             MOVS     R1,#+55
   \   0000004A   0x....             LDR.N    R0,??DataTable9_3
   \   0000004C   0x.... 0x....      BL       assert_failed
     56            
     57            if(ptx == PTA)
   \                     ??LPLD_GPIO_Init_2: (+1)
   \   00000050   0x....             LDR.N    R0,??DataTable9_4  ;; 0x400ff000
   \   00000052   0x4287             CMP      R7,R0
   \   00000054   0xD104             BNE.N    ??LPLD_GPIO_Init_3
     58            {
     59              portx = PORTA;  
   \   00000056   0x....             LDR.N    R0,??DataTable9_5  ;; 0x40049000
   \   00000058   0x0005             MOVS     R5,R0
     60              i = 0;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x0004             MOVS     R4,R0
   \   0000005E   0xE021             B.N      ??LPLD_GPIO_Init_4
     61            }
     62            else if(ptx == PTB) 
   \                     ??LPLD_GPIO_Init_3: (+1)
   \   00000060   0x....             LDR.N    R0,??DataTable9_6  ;; 0x400ff040
   \   00000062   0x4287             CMP      R7,R0
   \   00000064   0xD104             BNE.N    ??LPLD_GPIO_Init_5
     63            {
     64              portx = PORTB;
   \   00000066   0x....             LDR.N    R0,??DataTable9_7  ;; 0x4004a000
   \   00000068   0x0005             MOVS     R5,R0
     65              i = 1;
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0x0004             MOVS     R4,R0
   \   0000006E   0xE019             B.N      ??LPLD_GPIO_Init_4
     66            }
     67            else if(ptx == PTC) 
   \                     ??LPLD_GPIO_Init_5: (+1)
   \   00000070   0x....             LDR.N    R0,??DataTable9_8  ;; 0x400ff080
   \   00000072   0x4287             CMP      R7,R0
   \   00000074   0xD104             BNE.N    ??LPLD_GPIO_Init_6
     68            {
     69              portx = PORTC;
   \   00000076   0x....             LDR.N    R0,??DataTable9_9  ;; 0x4004b000
   \   00000078   0x0005             MOVS     R5,R0
     70              i = 2;
   \   0000007A   0x2002             MOVS     R0,#+2
   \   0000007C   0x0004             MOVS     R4,R0
   \   0000007E   0xE011             B.N      ??LPLD_GPIO_Init_4
     71            }
     72            else if(ptx == PTD) 
   \                     ??LPLD_GPIO_Init_6: (+1)
   \   00000080   0x....             LDR.N    R0,??DataTable9_10  ;; 0x400ff0c0
   \   00000082   0x4287             CMP      R7,R0
   \   00000084   0xD104             BNE.N    ??LPLD_GPIO_Init_7
     73            {
     74              portx = PORTD;
   \   00000086   0x....             LDR.N    R0,??DataTable9_11  ;; 0x4004c000
   \   00000088   0x0005             MOVS     R5,R0
     75              i = 3; 
   \   0000008A   0x2003             MOVS     R0,#+3
   \   0000008C   0x0004             MOVS     R4,R0
   \   0000008E   0xE009             B.N      ??LPLD_GPIO_Init_4
     76            }
     77            else if(ptx == PTE) 
   \                     ??LPLD_GPIO_Init_7: (+1)
   \   00000090   0x....             LDR.N    R0,??DataTable9_12  ;; 0x400ff100
   \   00000092   0x4287             CMP      R7,R0
   \   00000094   0xD104             BNE.N    ??LPLD_GPIO_Init_8
     78            {
     79              portx = PORTE;
   \   00000096   0x....             LDR.N    R0,??DataTable9_13  ;; 0x4004d000
   \   00000098   0x0005             MOVS     R5,R0
     80              i = 4;
   \   0000009A   0x2004             MOVS     R0,#+4
   \   0000009C   0x0004             MOVS     R4,R0
   \   0000009E   0xE001             B.N      ??LPLD_GPIO_Init_4
     81            }
     82            else
     83              return 0;
   \                     ??LPLD_GPIO_Init_8: (+1)
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xE02C             B.N      ??LPLD_GPIO_Init_9
     84            
     85            //输入或输出设置
     86            if(dir==DIR_OUTPUT)
   \                     ??LPLD_GPIO_Init_4: (+1)
   \   000000A4   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000A8   0xF1B9 0x0F01      CMP      R9,#+1
   \   000000AC   0xD10E             BNE.N    ??LPLD_GPIO_Init_10
     87            {
     88              ptx->PDDR |= pins;
   \   000000AE   0x6978             LDR      R0,[R7, #+20]
   \   000000B0   0xEA58 0x0000      ORRS     R0,R8,R0
   \   000000B4   0x6178             STR      R0,[R7, #+20]
     89              //设置初始输出
     90              if(output==OUTPUT_H)
   \   000000B6   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000BA   0xF1BA 0x0F01      CMP      R10,#+1
   \   000000BE   0xD102             BNE.N    ??LPLD_GPIO_Init_11
     91              {
     92                ptx->PSOR = pins; 
   \   000000C0   0xF8C7 0x8004      STR      R8,[R7, #+4]
   \   000000C4   0xE006             B.N      ??LPLD_GPIO_Init_12
     93              }
     94              else
     95              {
     96                ptx->PCOR = pins;
   \                     ??LPLD_GPIO_Init_11: (+1)
   \   000000C6   0xF8C7 0x8008      STR      R8,[R7, #+8]
   \   000000CA   0xE003             B.N      ??LPLD_GPIO_Init_12
     97              }
     98            }
     99            else
    100            { 
    101              ptx->PDDR &= ~(pins);
   \                     ??LPLD_GPIO_Init_10: (+1)
   \   000000CC   0x6978             LDR      R0,[R7, #+20]
   \   000000CE   0xEA30 0x0008      BICS     R0,R0,R8
   \   000000D2   0x6178             STR      R0,[R7, #+20]
    102            }
    103            
    104            //配置所选引脚的控制寄存器
    105            for(uint8 i=0; i<32; i++)
   \                     ??LPLD_GPIO_Init_12: (+1)
   \   000000D4   0x2000             MOVS     R0,#+0
   \                     ??LPLD_GPIO_Init_13: (+1)
   \   000000D6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D8   0x2820             CMP      R0,#+32
   \   000000DA   0xDA08             BGE.N    ??LPLD_GPIO_Init_14
    106            {
    107              if(pins&(1ul<<i))
   \   000000DC   0xFA38 0xF100      LSRS     R1,R8,R0
   \   000000E0   0x07C9             LSLS     R1,R1,#+31
   \   000000E2   0xD502             BPL.N    ??LPLD_GPIO_Init_15
    108              {
    109                portx->PCR[i] = pcr;
   \   000000E4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E6   0xF845 0x6020      STR      R6,[R5, R0, LSL #+2]
    110              }
    111            }
   \                     ??LPLD_GPIO_Init_15: (+1)
   \   000000EA   0x1C40             ADDS     R0,R0,#+1
   \   000000EC   0xE7F3             B.N      ??LPLD_GPIO_Init_13
    112          
    113            if(isr_func!=NULL)
   \                     ??LPLD_GPIO_Init_14: (+1)
   \   000000EE   0x4658             MOV      R0,R11
   \   000000F0   0x2800             CMP      R0,#+0
   \   000000F2   0xD003             BEQ.N    ??LPLD_GPIO_Init_16
    114              GPIO_ISR[i] = isr_func;
   \   000000F4   0x....             LDR.N    R0,??DataTable9_14
   \   000000F6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F8   0xF840 0xB024      STR      R11,[R0, R4, LSL #+2]
    115            
    116            return 1;
   \                     ??LPLD_GPIO_Init_16: (+1)
   \   000000FC   0x2001             MOVS     R0,#+1
   \                     ??LPLD_GPIO_Init_9: (+1)
   \   000000FE   0xE8BD 0x0FF2      POP      {R1,R4-R11}
   \   00000102   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    117          }
    118          
    119          /*
    120           * LPLD_GPIO_EnableIrq
    121           * 使能GPIO外部中断
    122           * 
    123           * 参数:
    124           *    gpio_init_structure--GPIO初始化结构体，
    125           *                        具体定义见GPIO_InitTypeDef
    126           *
    127           * 输出:
    128           *    0--配置错误
    129           *    1--配置成功
    130           *
    131           */

   \                                 In section .text, align 2, keep-with-next
    132          uint8 LPLD_GPIO_EnableIrq(GPIO_InitTypeDef gpio_init_structure)
    133          {
   \                     LPLD_GPIO_EnableIrq: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB538             PUSH     {R3-R5,LR}
    134            uint8 i;
    135            GPIO_Type *ptx = gpio_init_structure.GPIO_PTx;
   \   00000004   0x9D04             LDR      R5,[SP, #+16]
    136            
    137            //参数检查
    138            ASSERT( ptx <= PTE);                  //判断端口
   \   00000006   0x....             LDR.N    R0,??DataTable9_2  ;; 0x400ff101
   \   00000008   0x4285             CMP      R5,R0
   \   0000000A   0xD303             BCC.N    ??LPLD_GPIO_EnableIrq_0
   \   0000000C   0x218A             MOVS     R1,#+138
   \   0000000E   0x....             LDR.N    R0,??DataTable9_3
   \   00000010   0x.... 0x....      BL       assert_failed
    139            
    140            if(ptx == PTA)
   \                     ??LPLD_GPIO_EnableIrq_0: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable9_4  ;; 0x400ff000
   \   00000016   0x4285             CMP      R5,R0
   \   00000018   0xD102             BNE.N    ??LPLD_GPIO_EnableIrq_1
    141              i = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x0004             MOVS     R4,R0
   \   0000001E   0xE013             B.N      ??LPLD_GPIO_EnableIrq_2
    142            else if(ptx == PTB) 
   \                     ??LPLD_GPIO_EnableIrq_1: (+1)
   \   00000020   0x....             LDR.N    R0,??DataTable9_6  ;; 0x400ff040
   \   00000022   0x4285             CMP      R5,R0
   \   00000024   0xD102             BNE.N    ??LPLD_GPIO_EnableIrq_3
    143              i = 1;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x0004             MOVS     R4,R0
   \   0000002A   0xE00D             B.N      ??LPLD_GPIO_EnableIrq_2
    144            else if(ptx == PTC) 
   \                     ??LPLD_GPIO_EnableIrq_3: (+1)
   \   0000002C   0x....             LDR.N    R0,??DataTable9_8  ;; 0x400ff080
   \   0000002E   0x4285             CMP      R5,R0
   \   00000030   0xD102             BNE.N    ??LPLD_GPIO_EnableIrq_4
    145              i = 2;
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x0004             MOVS     R4,R0
   \   00000036   0xE007             B.N      ??LPLD_GPIO_EnableIrq_2
    146            else if(ptx == PTD) 
   \                     ??LPLD_GPIO_EnableIrq_4: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable9_10  ;; 0x400ff0c0
   \   0000003A   0x4285             CMP      R5,R0
   \   0000003C   0xD102             BNE.N    ??LPLD_GPIO_EnableIrq_5
    147              i = 3;
   \   0000003E   0x2003             MOVS     R0,#+3
   \   00000040   0x0004             MOVS     R4,R0
   \   00000042   0xE001             B.N      ??LPLD_GPIO_EnableIrq_2
    148            else
    149              i = 4;
   \                     ??LPLD_GPIO_EnableIrq_5: (+1)
   \   00000044   0x2004             MOVS     R0,#+4
   \   00000046   0x0004             MOVS     R4,R0
    150          
    151            enable_irq((IRQn_Type)(i + PORTA_IRQn));
   \                     ??LPLD_GPIO_EnableIrq_2: (+1)
   \   00000048   0xF114 0x0057      ADDS     R0,R4,#+87
   \   0000004C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000004E   0x.... 0x....      BL       NVIC_EnableIRQ
    152            
    153            return 1;
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xBC32             POP      {R1,R4,R5}
   \   00000056   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    154          }
    155          
    156          /*
    157           * LPLD_GPIO_DisableIrq
    158           * 禁用GPIO外部中断
    159           * 
    160           * 参数:
    161           *    gpio_init_structure--GPIO初始化结构体，
    162           *                        具体定义见GPIO_InitTypeDef
    163           *
    164           * 输出:
    165           *    0--配置错误
    166           *    1--配置成功
    167           *
    168           */

   \                                 In section .text, align 2, keep-with-next
    169          uint8 LPLD_GPIO_DisableIrq(GPIO_InitTypeDef gpio_init_structure)
    170          {
   \                     LPLD_GPIO_DisableIrq: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB538             PUSH     {R3-R5,LR}
    171            uint8 i;
    172            GPIO_Type *ptx = gpio_init_structure.GPIO_PTx;
   \   00000004   0x9D04             LDR      R5,[SP, #+16]
    173            
    174            //参数检查
    175            ASSERT( ptx <= PTE);                  //判断端口
   \   00000006   0x....             LDR.N    R0,??DataTable9_2  ;; 0x400ff101
   \   00000008   0x4285             CMP      R5,R0
   \   0000000A   0xD303             BCC.N    ??LPLD_GPIO_DisableIrq_0
   \   0000000C   0x21AF             MOVS     R1,#+175
   \   0000000E   0x....             LDR.N    R0,??DataTable9_3
   \   00000010   0x.... 0x....      BL       assert_failed
    176            
    177            if(ptx == PTA)
   \                     ??LPLD_GPIO_DisableIrq_0: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable9_4  ;; 0x400ff000
   \   00000016   0x4285             CMP      R5,R0
   \   00000018   0xD102             BNE.N    ??LPLD_GPIO_DisableIrq_1
    178              i = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x0004             MOVS     R4,R0
   \   0000001E   0xE013             B.N      ??LPLD_GPIO_DisableIrq_2
    179            else if(ptx == PTB) 
   \                     ??LPLD_GPIO_DisableIrq_1: (+1)
   \   00000020   0x....             LDR.N    R0,??DataTable9_6  ;; 0x400ff040
   \   00000022   0x4285             CMP      R5,R0
   \   00000024   0xD102             BNE.N    ??LPLD_GPIO_DisableIrq_3
    180              i = 1;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x0004             MOVS     R4,R0
   \   0000002A   0xE00D             B.N      ??LPLD_GPIO_DisableIrq_2
    181            else if(ptx == PTC) 
   \                     ??LPLD_GPIO_DisableIrq_3: (+1)
   \   0000002C   0x....             LDR.N    R0,??DataTable9_8  ;; 0x400ff080
   \   0000002E   0x4285             CMP      R5,R0
   \   00000030   0xD102             BNE.N    ??LPLD_GPIO_DisableIrq_4
    182              i = 2;
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x0004             MOVS     R4,R0
   \   00000036   0xE007             B.N      ??LPLD_GPIO_DisableIrq_2
    183            else if(ptx == PTD) 
   \                     ??LPLD_GPIO_DisableIrq_4: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable9_10  ;; 0x400ff0c0
   \   0000003A   0x4285             CMP      R5,R0
   \   0000003C   0xD102             BNE.N    ??LPLD_GPIO_DisableIrq_5
    184              i = 3;
   \   0000003E   0x2003             MOVS     R0,#+3
   \   00000040   0x0004             MOVS     R4,R0
   \   00000042   0xE001             B.N      ??LPLD_GPIO_DisableIrq_2
    185            else
    186              i = 4;
   \                     ??LPLD_GPIO_DisableIrq_5: (+1)
   \   00000044   0x2004             MOVS     R0,#+4
   \   00000046   0x0004             MOVS     R4,R0
    187            
    188            disable_irq((IRQn_Type)(i + PORTA_IRQn));
   \                     ??LPLD_GPIO_DisableIrq_2: (+1)
   \   00000048   0xF114 0x0057      ADDS     R0,R4,#+87
   \   0000004C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000004E   0x.... 0x....      BL       NVIC_DisableIRQ
    189            
    190            return 1;
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xBC32             POP      {R1,R4,R5}
   \   00000056   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    191          }
    192          
    193          /*
    194           * LPLD_GPIO_Ouptut
    195           * 设置GPIO端口0~31位的输出
    196           * 
    197           * 参数:
    198           *    ptx--端口号
    199           *      |__PTA        --Port A
    200           *      |__PTB        --Port B
    201           *      |__PTC        --Port C
    202           *      |__PTD        --Port D
    203           *      |__PTE        --Port E
    204           *    data32--输出数据
    205           *      |__0x00000000~0xFFFFFFFF--低到高代表GPIO口的第0~31位数据
    206           *
    207           * 输出:
    208           *
    209           */

   \                                 In section .text, align 2, keep-with-next
    210          __INLINE void LPLD_GPIO_Output(GPIO_Type *ptx, uint32 data32)
    211          { 
    212            ptx->PDOR = data32;
   \                     LPLD_GPIO_Output: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
    213          }
   \   00000002   0x4770             BX       LR               ;; return
    214          
    215          /*
    216           * LPLD_GPIO_Ouptut_b
    217           * 设置GPIO端口一位的输出
    218           * 
    219           * 参数:
    220           *    ptx--端口号
    221           *      |__PTA        --Port A
    222           *      |__PTB        --Port B
    223           *      |__PTC        --Port C
    224           *      |__PTD        --Port D
    225           *      |__PTE        --Port E
    226           *    lsb_num--端口引脚位数编号
    227           *      |__0~31       --GPIO口的第0~31位
    228           *    data1--输出数据
    229           *      |__0          --输出低电平
    230           *      |__1          --输出高电平
    231           *
    232           * 输出:
    233           *
    234           */

   \                                 In section .text, align 2, keep-with-next
    235          __INLINE void LPLD_GPIO_Output_b(GPIO_Type *ptx, uint32 lsb_num, uint8 data1)
    236          {
   \                     LPLD_GPIO_Output_b: (+1)
   \   00000000   0xB410             PUSH     {R4}
    237            ptx->PDOR = (ptx->PDOR & ~(0x01L<<lsb_num)) | (uint32)data1<<lsb_num;
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0x2401             MOVS     R4,#+1
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x43A3             BICS     R3,R3,R4
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0xFA12 0xF401      LSLS     R4,R2,R1
   \   00000010   0x4323             ORRS     R3,R4,R3
   \   00000012   0x6003             STR      R3,[R0, #+0]
    238          }
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4770             BX       LR               ;; return
    239          
    240          /*
    241           * LPLD_GPIO_Ouptut_8b
    242           * 设置GPIO端口8位的输出
    243           * 
    244           * 参数:
    245           *    ptx--端口号
    246           *      |__PTA        --Port A
    247           *      |__PTB        --Port B
    248           *      |__PTC        --Port C
    249           *      |__PTD        --Port D
    250           *      |__PTE        --Port E
    251           *    lsb_num--代表8个端口引脚的最低位数编号
    252           *      |__0~24       --GPIO口的第0~24位
    253           *    data8--输出数据
    254           *      |__0x00~0xFF--代表GPIO口输出的8位数据
    255           *
    256           * 输出:
    257           *
    258           */

   \                                 In section .text, align 2, keep-with-next
    259          __INLINE void LPLD_GPIO_Output_8b(GPIO_Type *ptx, uint8 lsb_num, uint8 data8)
    260          {
   \                     LPLD_GPIO_Output_8b: (+1)
   \   00000000   0xB410             PUSH     {R4}
    261            ptx->PDOR = (ptx->PDOR & ~(0xFFL<<lsb_num)) | (uint32)data8<<lsb_num;
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0x24FF             MOVS     R4,#+255
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x43A3             BICS     R3,R3,R4
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0xFA12 0xF401      LSLS     R4,R2,R1
   \   00000010   0x4323             ORRS     R3,R4,R3
   \   00000012   0x6003             STR      R3,[R0, #+0]
    262          }
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4770             BX       LR               ;; return
    263          
    264          /*
    265           * LPLD_GPIO_Toggle
    266           * 设置GPIO端口0~31的电平翻转
    267           * 
    268           * 参数:
    269           *    ptx--端口号
    270           *      |__PTA        --Port A
    271           *      |__PTB        --Port B
    272           *      |__PTC        --Port C
    273           *      |__PTD        --Port D
    274           *      |__PTE        --Port E
    275           *    data32--翻转数据
    276           *      |__0x00000000~0xFFFFFFFF--低到高代表GPIO口的第0~31位的翻转，1为反转，0为保持不变。
    277           *
    278           * 输出:
    279           *
    280           */

   \                                 In section .text, align 2, keep-with-next
    281          __INLINE void LPLD_GPIO_Toggle(GPIO_Type *ptx, uint32 data32)
    282          {  
    283            ptx->PTOR = data32;
   \                     LPLD_GPIO_Toggle: (+1)
   \   00000000   0x60C1             STR      R1,[R0, #+12]
    284          }
   \   00000002   0x4770             BX       LR               ;; return
    285          
    286          /*
    287           * LPLD_GPIO_Toggle_b
    288           * 设置GPIO端口一位的翻转
    289           * 
    290           * 参数:
    291           *    ptx--端口号
    292           *      |__PTA        --Port A
    293           *      |__PTB        --Port B
    294           *      |__PTC        --Port C
    295           *      |__PTD        --Port D
    296           *      |__PTE        --Port E
    297           *    lsb_num--端口引脚位数编号
    298           *      |__0~31       --GPIO口的第0~31位
    299           *
    300           * 输出:
    301           *
    302           */

   \                                 In section .text, align 2, keep-with-next
    303          __INLINE void LPLD_GPIO_Toggle_b(GPIO_Type *ptx, uint8 lsb_num)
    304          {  
    305            ptx->PTOR = 0x01L<<lsb_num;
   \                     LPLD_GPIO_Toggle_b: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0x408A             LSLS     R2,R2,R1
   \   00000004   0x60C2             STR      R2,[R0, #+12]
    306          }
   \   00000006   0x4770             BX       LR               ;; return
    307          
    308          /*
    309           * LPLD_GPIO_Toggle_8b
    310           * 设置GPIO端口8位的翻转
    311           * 
    312           * 参数:
    313           *    ptx--端口号
    314           *      |__PTA        --Port A
    315           *      |__PTB        --Port B
    316           *      |__PTC        --Port C
    317           *      |__PTD        --Port D
    318           *      |__PTE        --Port E
    319           *    lsb_num--代表8个端口引脚的最低位数编号
    320           *      |__0~24       --GPIO口的第0~24位
    321           *    data8--输出数据
    322           *      |__0x00~0xFF--代表GPIO口输出的8位数据
    323           *
    324           * 输出:
    325           *
    326           */

   \                                 In section .text, align 2, keep-with-next
    327          __INLINE void LPLD_GPIO_Toggle_8b(GPIO_Type *ptx, uint8 lsb_num, uint8 data8)
    328          {
    329            ptx->PTOR = (uint32)data8<<lsb_num;
   \                     LPLD_GPIO_Toggle_8b: (+1)
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0xFA12 0xF301      LSLS     R3,R2,R1
   \   00000006   0x60C3             STR      R3,[R0, #+12]
    330          }
   \   00000008   0x4770             BX       LR               ;; return
    331          
    332          /*
    333           * LPLD_GPIO_Input
    334           * 取得GPIO口0~31位的数据
    335           * 
    336           * 参数:
    337           *    ptx--端口号
    338           *      |__PTA        --Port A
    339           *      |__PTB        --Port B
    340           *      |__PTC        --Port C
    341           *      |__PTD        --Port D
    342           *      |__PTE        --Port E
    343           *
    344           * 输出:
    345           *    指定GPIO口的32位输入
    346           *
    347           */

   \                                 In section .text, align 2, keep-with-next
    348          __INLINE uint32 LPLD_GPIO_Input(GPIO_Type *ptx)
    349          {
    350            return ptx->PDIR;
   \                     LPLD_GPIO_Input: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x4770             BX       LR               ;; return
    351          }
    352          
    353          /*
    354           * LPLD_GPIO_Input_b
    355           * 取得GPIO口某一位的数据
    356           * 
    357           * 参数:
    358           *    ptx--端口号
    359           *      |__PTA        --Port A
    360           *      |__PTB        --Port B
    361           *      |__PTC        --Port C
    362           *      |__PTD        --Port D
    363           *      |__PTE        --Port E
    364           *    lsb_num--端口引脚位数编号
    365           *      |__0~31       --GPIO口的第0~31位
    366           *
    367           * 输出:
    368           *    指定GPIO口的指定位数的电平
    369           *
    370           */

   \                                 In section .text, align 2, keep-with-next
    371          __INLINE uint8 LPLD_GPIO_Input_b(GPIO_Type *ptx, uint8 lsb_num)
    372          {  
    373            return (uint8)((ptx->PDIR>>lsb_num)&0x01L);
   \                     LPLD_GPIO_Input_b: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x40C8             LSRS     R0,R0,R1
   \   00000004   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000008   0x4770             BX       LR               ;; return
    374          }
    375          
    376          /*
    377           * LPLD_GPIO_Input_8b
    378           * 取得GPIO端口8位数据的输入
    379           * 
    380           * 参数:
    381           *    ptx--端口号
    382           *      |__PTA        --Port A
    383           *      |__PTB        --Port B
    384           *      |__PTC        --Port C
    385           *      |__PTD        --Port D
    386           *      |__PTE        --Port E
    387           *    lsb_num--代表8个端口引脚的最低位数编号
    388           *      |__0~24       --GPIO口的第0~24位
    389           *
    390           * 输出:
    391           *    指定GPIO口的8位数据的电平
    392           *
    393           */

   \                                 In section .text, align 2, keep-with-next
    394          __INLINE uint8 LPLD_GPIO_Input_8b(GPIO_Type *ptx, uint8 lsb_num)
    395          {
    396            return (uint8)((ptx->PDIR>>lsb_num)&0xFFL);
   \                     LPLD_GPIO_Input_8b: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x40C8             LSRS     R0,R0,R1
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x4770             BX       LR               ;; return
    397          }
    398          
    399          /*
    400           * PORTA--PORTE中断处理函数
    401           * 与启动文件startup_K60.s中的中断向量表关联
    402           * 用户无需修改，程序自动进入对应通道中断函数
    403           */

   \                                 In section .text, align 2, keep-with-next
    404          void PORTA_IRQHandler(void)
    405          {
   \                     PORTA_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    406          #if (UCOS_II > 0u)
    407            OS_CPU_SR  cpu_sr = 0u;
    408            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    409            OSIntEnter();
    410            OS_EXIT_CRITICAL();
    411          #endif
    412            
    413            //调用用户自定义中断服务
    414            GPIO_ISR[0](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_14
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    415            PORTA->ISFR =0xFFFFFFFF;
   \   00000008   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_15  ;; 0x400490a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    416            
    417          #if (UCOS_II > 0u)
    418            OSIntExit();          //告知系统此时即将离开中断服务子函数
    419          #endif
    420          }//           ;87:  PORT A interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    421          

   \                                 In section .text, align 2, keep-with-next
    422          void PORTB_IRQHandler(void)
    423          {
   \                     PORTB_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    424          #if (UCOS_II > 0u)
    425            OS_CPU_SR  cpu_sr = 0u;
    426            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    427            OSIntEnter();
    428            OS_EXIT_CRITICAL();
    429          #endif
    430            
    431            //调用用户自定义中断服务
    432            GPIO_ISR[1](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_14
   \   00000004   0x6840             LDR      R0,[R0, #+4]
   \   00000006   0x4780             BLX      R0
    433            PORTB->ISFR =0xFFFFFFFF;
   \   00000008   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_16  ;; 0x4004a0a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    434            
    435          #if (UCOS_II > 0u)
    436            OSIntExit();          //告知系统此时即将离开中断服务子函数
    437          #endif
    438          }//           ;88:  PORT B interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    439          

   \                                 In section .text, align 2, keep-with-next
    440          void PORTC_IRQHandler(void)
    441          {
   \                     PORTC_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    442          #if (UCOS_II > 0u)
    443            OS_CPU_SR  cpu_sr = 0u;
    444            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    445            OSIntEnter();
    446            OS_EXIT_CRITICAL();
    447          #endif
    448            
    449            //调用用户自定义中断服务
    450            GPIO_ISR[2](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_14
   \   00000004   0x6880             LDR      R0,[R0, #+8]
   \   00000006   0x4780             BLX      R0
    451            PORTC->ISFR =0xFFFFFFFF;
   \   00000008   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_17  ;; 0x4004b0a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    452            
    453          #if (UCOS_II > 0u)
    454            OSIntExit();          //告知系统此时即将离开中断服务子函数
    455          #endif
    456          }//           ;89:  PORT C interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    457          

   \                                 In section .text, align 2, keep-with-next
    458          void PORTD_IRQHandler(void)
    459          {
   \                     PORTD_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    460          #if (UCOS_II > 0u)
    461            OS_CPU_SR  cpu_sr = 0u;
    462            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    463            OSIntEnter();
    464            OS_EXIT_CRITICAL();
    465          #endif
    466            
    467            //调用用户自定义中断服务
    468            GPIO_ISR[3](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_14
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0x4780             BLX      R0
    469            PORTD->ISFR =0xFFFFFFFF;
   \   00000008   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_18  ;; 0x4004c0a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    470            
    471          #if (UCOS_II > 0u)
    472            OSIntExit();          //告知系统此时即将离开中断服务子函数
    473          #endif
    474          }//           ;90:  PORT D interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    475          

   \                                 In section .text, align 2, keep-with-next
    476          void PORTE_IRQHandler(void)
    477          {
   \                     PORTE_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    478          #if (UCOS_II > 0u)
    479            OS_CPU_SR  cpu_sr = 0u;
    480            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    481            OSIntEnter();
    482            OS_EXIT_CRITICAL();
    483          #endif
    484            
    485            //调用用户自定义中断服务
    486            GPIO_ISR[4](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_14
   \   00000004   0x6900             LDR      R0,[R0, #+16]
   \   00000006   0x4780             BLX      R0
    487            PORTE->ISFR =0xFFFFFFFF;
   \   00000008   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_19  ;; 0x4004d0a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    488            
    489          #if (UCOS_II > 0u)
    490            OSIntExit();          //告知系统此时即将离开中断服务子函数
    491          #endif
    492          }//           ;91:  PORT E interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x400FF101         DC32     0x400ff101

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x400FF000         DC32     0x400ff000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x40049000         DC32     0x40049000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x400FF040         DC32     0x400ff040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x4004A000         DC32     0x4004a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x400FF080         DC32     0x400ff080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x4004B000         DC32     0x4004b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x400FF0C0         DC32     0x400ff0c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x4004C000         DC32     0x4004c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x400FF100         DC32     0x400ff100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x4004D000         DC32     0x4004d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x........         DC32     GPIO_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   0x400490A0         DC32     0x400490a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \   00000000   0x4004A0A0         DC32     0x4004a0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \   00000000   0x4004B0A0         DC32     0x4004b0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_18:
   \   00000000   0x4004C0A0         DC32     0x4004c0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_19:
   \   00000000   0x4004D0A0         DC32     0x4004d0a0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 0B0H, 0D9H, 0B6H, 0C8H, 0D4H
   \              0x5C 0xB0    
   \              0xD9 0xB6    
   \              0xC8 0xD4    
   \   00000008   0xC6 0xCD          DC8 0C6H, 0CDH, 0ACH, 0B2H, 0BDH, 0C5H, 0CCH, 5CH
   \              0xAC 0xB2    
   \              0xBD 0xC5    
   \              0xCC 0x5C    
   \   00000010   0xB1 0xC8          DC8 0B1H, 0C8H, 0C8H, 0FCH, 0B4H, 0FAH, 0C2H, 0EBH
   \              0xC8 0xFC    
   \              0xB4 0xFA    
   \              0xC2 0xEB    
   \   00000018   0x5C 0x4C          DC8 5CH, 4CH, 50H, 4CH, 44H, 5FH, 4FH, 53H
   \              0x50 0x4C    
   \              0x44 0x5F    
   \              0x4F 0x53    
   \   00000020   0x4B 0x69          DC8 4BH, 69H, 6EH, 65H, 74H, 69H, 73H, 5FH
   \              0x6E 0x65    
   \              0x74 0x69    
   \              0x73 0x5F    
   \   00000028   0x56 0x33          DC8 56H, 33H, 5CH, 6CH, 69H, 62H, 5CH, 4CH
   \              0x5C 0x6C    
   \              0x69 0x62    
   \              0x5C 0x4C    
   \   00000030   0x50 0x4C          DC8 50H, 4CH, 44H, 5CH, 48H, 57H, 5CH, 48H
   \              0x44 0x5C    
   \              0x48 0x57    
   \              0x5C 0x48    
   \   00000038   0x57 0x5F          DC8 57H, 5FH, 47H, 50H, 49H, 4FH, 2EH, 63H
   \              0x47 0x50    
   \              0x49 0x4F    
   \              0x2E 0x63    
   \   00000040   0x00               DC8 0
   \   00000041   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   LPLD_GPIO_DisableIrq
        32   -> NVIC_DisableIRQ
        32   -> assert_failed
      32   LPLD_GPIO_EnableIrq
        32   -> NVIC_EnableIRQ
        32   -> assert_failed
      56   LPLD_GPIO_Init
        56   -> assert_failed
       0   LPLD_GPIO_Input
       0   LPLD_GPIO_Input_8b
       0   LPLD_GPIO_Input_b
       0   LPLD_GPIO_Output
       4   LPLD_GPIO_Output_8b
       4   LPLD_GPIO_Output_b
       0   LPLD_GPIO_Toggle
       0   LPLD_GPIO_Toggle_8b
       0   LPLD_GPIO_Toggle_b
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ
       8   PORTA_IRQHandler
         8   -- Indirect call
       8   PORTB_IRQHandler
         8   -- Indirect call
       8   PORTC_IRQHandler
         8   -- Indirect call
       8   PORTD_IRQHandler
         8   -- Indirect call
       8   PORTE_IRQHandler
         8   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_18
       4  ??DataTable9_19
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      68  ?_0
      20  GPIO_ISR
      90  LPLD_GPIO_DisableIrq
      90  LPLD_GPIO_EnableIrq
     262  LPLD_GPIO_Init
       4  LPLD_GPIO_Input
       8  LPLD_GPIO_Input_8b
      10  LPLD_GPIO_Input_b
       4  LPLD_GPIO_Output
      24  LPLD_GPIO_Output_8b
      24  LPLD_GPIO_Output_b
       4  LPLD_GPIO_Toggle
      10  LPLD_GPIO_Toggle_8b
       8  LPLD_GPIO_Toggle_b
      20  NVIC_DisableIRQ
      20  NVIC_EnableIRQ
      18  PORTA_IRQHandler
      18  PORTB_IRQHandler
      18  PORTC_IRQHandler
      18  PORTD_IRQHandler
      18  PORTE_IRQHandler

 
  20 bytes in section .bss
  68 bytes in section .rodata
 748 bytes in section .text
 
 748 bytes of CODE  memory
  68 bytes of CONST memory
  20 bytes of DATA  memory

Errors: none
Warnings: none
