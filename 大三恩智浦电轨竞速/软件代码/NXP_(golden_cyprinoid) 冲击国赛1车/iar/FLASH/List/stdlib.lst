###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.3.8024/W32 for ARM        16/Aug/2016  11:11:20
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\lib\common\stdlib.c
#    Command line =  
#        E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\lib\common\stdlib.c -D LPLD_K60
#        -lCN
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\FLASH\List\" -lB
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\FLASH\List\" -o
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\FLASH\Obj\" --no_cse --no_unroll --no_inline --no_code_motion
#        --no_tbaa --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        D:\IAR\arm\INC\c\DLib_Config_Normal.h -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\app\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\app\BSP\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\app\ITAC\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\app\CTL\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\app\MAIN\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\app\SENSOR\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\CPU\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\common\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\LPLD\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\LPLD\HW\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\LPLD\DEV\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\uCOS-II\Ports\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\uCOS-II\Source\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\FatFs\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\FatFs\option\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\USB\common\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\USB\driver\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\USB\descriptor\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\USB\class\" -On -I D:\IAR\arm\CMSIS\Include\ -D
#        ARM_MATH_CM4
#    List file    =  
#        E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\FLASH\List\stdlib.lst
#    Object file  =  
#        E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\FLASH\Obj\stdlib.o
#
###############################################################################

E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\lib\common\stdlib.c
      1          /**
      2           * @file stdlib.c
      3           * @version 3.01[By LPLD]
      4           * @date 2013-11-4
      5           * @brief C标准代码库
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * 由标准C代码库移植，仅支持ASCII
     10           *
     11           * 版权所有:北京拉普兰德电子技术有限公司
     12           * http://www.lpld.cn
     13           * mail:support@lpld.cn
     14           *
     15           * @par
     16           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     17           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     18           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     19           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     20           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     21           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     22           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     23           */
     24          #include "stdlib.h"
     25          
     26          
     27          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     28          int isspace (int ch)
     29          {
   \                     isspace: (+1)
   \   00000000   0x0001             MOVS     R1,R0
     30              if ((ch == ' ') || (ch == '\t'))    /* \n ??? */
   \   00000002   0x2920             CMP      R1,#+32
   \   00000004   0xD001             BEQ.N    ??isspace_0
   \   00000006   0x2909             CMP      R1,#+9
   \   00000008   0xD101             BNE.N    ??isspace_1
     31                  return TRUE;
   \                     ??isspace_0: (+1)
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE000             B.N      ??isspace_2
     32              else
     33                  return FALSE;
   \                     ??isspace_1: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??isspace_2: (+1)
   \   00000010   0x4770             BX       LR               ;; return
     34          }
     35          
     36          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     37          int isalnum (int ch)
     38          {
   \                     isalnum: (+1)
   \   00000000   0x0001             MOVS     R1,R0
     39              /* ASCII only */
     40              if (((ch >= '0') && (ch <= '9')) ||
     41                  ((ch >= 'A') && (ch <= 'Z')) ||
     42                  ((ch >= 'a') && (ch <= 'z')))
   \   00000002   0x2930             CMP      R1,#+48
   \   00000004   0xDB01             BLT.N    ??isalnum_0
   \   00000006   0x293A             CMP      R1,#+58
   \   00000008   0xDB07             BLT.N    ??isalnum_1
   \                     ??isalnum_0: (+1)
   \   0000000A   0x2941             CMP      R1,#+65
   \   0000000C   0xDB01             BLT.N    ??isalnum_2
   \   0000000E   0x295B             CMP      R1,#+91
   \   00000010   0xDB03             BLT.N    ??isalnum_1
   \                     ??isalnum_2: (+1)
   \   00000012   0x2961             CMP      R1,#+97
   \   00000014   0xDB03             BLT.N    ??isalnum_3
   \   00000016   0x297B             CMP      R1,#+123
   \   00000018   0xDA01             BGE.N    ??isalnum_3
     43                  return TRUE;
   \                     ??isalnum_1: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE000             B.N      ??isalnum_4
     44              else
     45                  return FALSE;
   \                     ??isalnum_3: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \                     ??isalnum_4: (+1)
   \   00000020   0x4770             BX       LR               ;; return
     46          }
     47          
     48          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     49          int isdigit (int ch)
     50          {
   \                     isdigit: (+1)
   \   00000000   0x0001             MOVS     R1,R0
     51              /* ASCII only */
     52              if ((ch >= '0') && (ch <= '9'))
   \   00000002   0x2930             CMP      R1,#+48
   \   00000004   0xDB03             BLT.N    ??isdigit_0
   \   00000006   0x293A             CMP      R1,#+58
   \   00000008   0xDA01             BGE.N    ??isdigit_0
     53                  return TRUE;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE000             B.N      ??isdigit_1
     54              else
     55                  return FALSE;
   \                     ??isdigit_0: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??isdigit_1: (+1)
   \   00000010   0x4770             BX       LR               ;; return
     56          }
     57          
     58          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     59          int isupper (int ch)
     60          {
   \                     isupper: (+1)
   \   00000000   0x0001             MOVS     R1,R0
     61              /* ASCII only */
     62              if ((ch >= 'A') && (ch <= 'Z'))
   \   00000002   0x2941             CMP      R1,#+65
   \   00000004   0xDB03             BLT.N    ??isupper_0
   \   00000006   0x295B             CMP      R1,#+91
   \   00000008   0xDA01             BGE.N    ??isupper_0
     63                  return TRUE;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE000             B.N      ??isupper_1
     64              else
     65                  return FALSE;
   \                     ??isupper_0: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??isupper_1: (+1)
   \   00000010   0x4770             BX       LR               ;; return
     66          }
     67          
     68          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     69          int strcasecmp (const int8 *s1, const int8 *s2)
     70          {
   \                     strcasecmp: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
     71              int8    c1, c2;
     72              int     result = 0;
   \   00000004   0x2000             MOVS     R0,#+0
     73          
     74              while (result == 0)
   \                     ??strcasecmp_0: (+1)
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD121             BNE.N    ??strcasecmp_1
     75              {
     76                  c1 = *s1++;
   \   0000000A   0xF992 0x5000      LDRSB    R5,[R2, #+0]
   \   0000000E   0x002B             MOVS     R3,R5
   \   00000010   0x1C52             ADDS     R2,R2,#+1
     77                  c2 = *s2++;
   \   00000012   0xF991 0x5000      LDRSB    R5,[R1, #+0]
   \   00000016   0x002C             MOVS     R4,R5
   \   00000018   0x1C49             ADDS     R1,R1,#+1
     78                  if ((c1 >= 'a') && (c1 <= 'z'))
   \   0000001A   0xB25B             SXTB     R3,R3            ;; SignExt  R3,R3,#+24,#+24
   \   0000001C   0x2B61             CMP      R3,#+97
   \   0000001E   0xDB03             BLT.N    ??strcasecmp_2
   \   00000020   0xB25B             SXTB     R3,R3            ;; SignExt  R3,R3,#+24,#+24
   \   00000022   0x2B7B             CMP      R3,#+123
   \   00000024   0xDA00             BGE.N    ??strcasecmp_2
     79                      c1 = (int8)(c1 - ' ');
   \   00000026   0x3B20             SUBS     R3,R3,#+32
     80                  if ((c2 >= 'a') && (c2 <= 'z'))
   \                     ??strcasecmp_2: (+1)
   \   00000028   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   0000002A   0x2C61             CMP      R4,#+97
   \   0000002C   0xDB03             BLT.N    ??strcasecmp_3
   \   0000002E   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   00000030   0x2C7B             CMP      R4,#+123
   \   00000032   0xDA00             BGE.N    ??strcasecmp_3
     81                      c2 = (int8)(c2 - ' ');
   \   00000034   0x3C20             SUBS     R4,R4,#+32
     82                  if ((result = (c1 - c2)) != 0)
   \                     ??strcasecmp_3: (+1)
   \   00000036   0xB25B             SXTB     R3,R3            ;; SignExt  R3,R3,#+24,#+24
   \   00000038   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   0000003A   0x1B1D             SUBS     R5,R3,R4
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD105             BNE.N    ??strcasecmp_1
     83                      break;
     84                  if ((c1 == 0) || (c2 == 0))
   \                     ??strcasecmp_4: (+1)
   \   00000042   0xB25B             SXTB     R3,R3            ;; SignExt  R3,R3,#+24,#+24
   \   00000044   0x2B00             CMP      R3,#+0
   \   00000046   0xD002             BEQ.N    ??strcasecmp_5
   \   00000048   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   0000004A   0x2C00             CMP      R4,#+0
   \   0000004C   0xD1DB             BNE.N    ??strcasecmp_0
     85                      break;
     86              }
     87              return result;
   \                     ??strcasecmp_5: (+1)
   \                     ??strcasecmp_1: (+1)
   \   0000004E   0xBC30             POP      {R4,R5}
   \   00000050   0x4770             BX       LR               ;; return
     88          }
     89          
     90          
     91          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     92          int strncasecmp (const int8 *s1, const int8 *s2, int n)
     93          {
   \                     strncasecmp: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0003             MOVS     R3,R0
     94              int8    c1, c2;
     95              int     k = 0;
   \   00000004   0x2600             MOVS     R6,#+0
     96              int     result = 0;
   \   00000006   0x2000             MOVS     R0,#+0
     97          
     98              while ( k++ < n )
   \                     ??strncasecmp_0: (+1)
   \   00000008   0x0037             MOVS     R7,R6
   \   0000000A   0x1C7E             ADDS     R6,R7,#+1
   \   0000000C   0x4297             CMP      R7,R2
   \   0000000E   0xDA21             BGE.N    ??strncasecmp_1
     99              {
    100                  c1 = *s1++;
   \   00000010   0xF993 0x7000      LDRSB    R7,[R3, #+0]
   \   00000014   0x003C             MOVS     R4,R7
   \   00000016   0x1C5B             ADDS     R3,R3,#+1
    101                  c2 = *s2++;
   \   00000018   0xF991 0x7000      LDRSB    R7,[R1, #+0]
   \   0000001C   0x003D             MOVS     R5,R7
   \   0000001E   0x1C49             ADDS     R1,R1,#+1
    102                  if ((c1 >= 'a') && (c1 <= 'z'))
   \   00000020   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   00000022   0x2C61             CMP      R4,#+97
   \   00000024   0xDB03             BLT.N    ??strncasecmp_2
   \   00000026   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   00000028   0x2C7B             CMP      R4,#+123
   \   0000002A   0xDA00             BGE.N    ??strncasecmp_2
    103                      c1 = (int8)(c1 - ' ');
   \   0000002C   0x3C20             SUBS     R4,R4,#+32
    104                  if ((c2 >= 'a') && (c2 <= 'z'))
   \                     ??strncasecmp_2: (+1)
   \   0000002E   0xB26D             SXTB     R5,R5            ;; SignExt  R5,R5,#+24,#+24
   \   00000030   0x2D61             CMP      R5,#+97
   \   00000032   0xDB03             BLT.N    ??strncasecmp_3
   \   00000034   0xB26D             SXTB     R5,R5            ;; SignExt  R5,R5,#+24,#+24
   \   00000036   0x2D7B             CMP      R5,#+123
   \   00000038   0xDA00             BGE.N    ??strncasecmp_3
    105                      c2 = (int8)(c2 - ' ');
   \   0000003A   0x3D20             SUBS     R5,R5,#+32
    106                  if ((result = (c1 - c2)) != 0)
   \                     ??strncasecmp_3: (+1)
   \   0000003C   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   0000003E   0xB26D             SXTB     R5,R5            ;; SignExt  R5,R5,#+24,#+24
   \   00000040   0x1B67             SUBS     R7,R4,R5
   \   00000042   0x0038             MOVS     R0,R7
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD105             BNE.N    ??strncasecmp_1
    107                      break;
    108                  if ((c1 == 0) || (c2 == 0))
   \                     ??strncasecmp_4: (+1)
   \   00000048   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   0000004A   0x2C00             CMP      R4,#+0
   \   0000004C   0xD002             BEQ.N    ??strncasecmp_5
   \   0000004E   0xB26D             SXTB     R5,R5            ;; SignExt  R5,R5,#+24,#+24
   \   00000050   0x2D00             CMP      R5,#+0
   \   00000052   0xD1D9             BNE.N    ??strncasecmp_0
    109                      break;
    110              }
    111              return result;
   \                     ??strncasecmp_5: (+1)
   \                     ??strncasecmp_1: (+1)
   \   00000054   0xBCF0             POP      {R4-R7}
   \   00000056   0x4770             BX       LR               ;; return
    112          }
    113          
    114          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    115          unsigned long strtoul (int8 *str, int8 **ptr, int base)
    116          {
   \                     strtoul: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    117              unsigned long rvalue;
    118              int c, err, neg;
    119              int8 *endp;
    120              int8 *startp;
    121          
    122              rvalue = 0;  err = 0;  neg = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0007             MOVS     R7,R0
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x9000             STR      R0,[SP, #+0]
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4680             MOV      R8,R0
    123          
    124              /* Check for invalid arguments */
    125              if ((str == NULL) || (base < 0) || (base == 1) || (base > 36))
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD005             BEQ.N    ??strtoul_0
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD403             BMI.N    ??strtoul_0
   \   0000001E   0x2E01             CMP      R6,#+1
   \   00000020   0xD001             BEQ.N    ??strtoul_0
   \   00000022   0x2E25             CMP      R6,#+37
   \   00000024   0xDB04             BLT.N    ??strtoul_1
    126              {
    127                  if (ptr != NULL)
   \                     ??strtoul_0: (+1)
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD000             BEQ.N    ??strtoul_2
    128                  {
    129                      *ptr = str;
   \   0000002A   0x602C             STR      R4,[R5, #+0]
    130                  }
    131                  return 0;
   \                     ??strtoul_2: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE069             B.N      ??strtoul_3
    132              }
    133          
    134              /* Skip leading white spaces */
    135              for (startp = str; isspace(*startp); ++startp)
   \                     ??strtoul_1: (+1)
   \   00000030   0x46A2             MOV      R10,R4
   \                     ??strtoul_4: (+1)
   \   00000032   0xF99A 0x0000      LDRSB    R0,[R10, #+0]
   \   00000036   0x.... 0x....      BL       isspace
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD002             BEQ.N    ??strtoul_5
   \   0000003E   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   00000042   0xE7F6             B.N      ??strtoul_4
    136                  ;
    137          
    138              /* Check for notations */
    139              switch (startp[0])
   \                     ??strtoul_5: (+1)
   \   00000044   0xF99A 0x0000      LDRSB    R0,[R10, #+0]
   \   00000048   0x282D             CMP      R0,#+45
   \   0000004A   0xD012             BEQ.N    ??strtoul_6
   \   0000004C   0x2830             CMP      R0,#+48
   \   0000004E   0xD115             BNE.N    ??strtoul_7
    140              {
    141                  case '0':
    142                      if ((startp[1] == 'x') || (startp[1] == 'X'))
   \                     ??strtoul_8: (+1)
   \   00000050   0xF99A 0x0001      LDRSB    R0,[R10, #+1]
   \   00000054   0x2878             CMP      R0,#+120
   \   00000056   0xD003             BEQ.N    ??strtoul_9
   \   00000058   0xF99A 0x0001      LDRSB    R0,[R10, #+1]
   \   0000005C   0x2858             CMP      R0,#+88
   \   0000005E   0xD107             BNE.N    ??strtoul_10
    143                      {
    144                          if ((base == 0) || (base == 16))
   \                     ??strtoul_9: (+1)
   \   00000060   0x2E00             CMP      R6,#+0
   \   00000062   0xD001             BEQ.N    ??strtoul_11
   \   00000064   0x2E10             CMP      R6,#+16
   \   00000066   0xD103             BNE.N    ??strtoul_10
    145                          {
    146                              base = 16;
   \                     ??strtoul_11: (+1)
   \   00000068   0x2010             MOVS     R0,#+16
   \   0000006A   0x0006             MOVS     R6,R0
    147                              startp = &startp[2];
   \   0000006C   0xF11A 0x0A02      ADDS     R10,R10,#+2
    148                          }
    149                      }
    150                      break;
   \                     ??strtoul_10: (+1)
   \   00000070   0xE004             B.N      ??strtoul_12
    151                  case '-':
    152                      neg = 1;
   \                     ??strtoul_6: (+1)
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x4680             MOV      R8,R0
    153                      startp = &startp[1];
   \   00000076   0xF11A 0x0A01      ADDS     R10,R10,#+1
    154                      break;
   \   0000007A   0xE7FF             B.N      ??strtoul_12
    155                  default:
    156                      break;
    157              }
    158          
    159              if (base == 0)
   \                     ??strtoul_7: (+1)
   \                     ??strtoul_12: (+1)
   \   0000007C   0x2E00             CMP      R6,#+0
   \   0000007E   0xD101             BNE.N    ??strtoul_13
    160                  base = 10;
   \   00000080   0x200A             MOVS     R0,#+10
   \   00000082   0x0006             MOVS     R6,R0
    161          
    162              /* Check for invalid chars in str */
    163              for ( endp = startp; (c = *endp) != '\0'; ++endp)
   \                     ??strtoul_13: (+1)
   \   00000084   0x46D1             MOV      R9,R10
   \                     ??strtoul_14: (+1)
   \   00000086   0xF999 0x0000      LDRSB    R0,[R9, #+0]
   \   0000008A   0x4683             MOV      R11,R0
   \   0000008C   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000090   0xD02B             BEQ.N    ??strtoul_15
    164              {
    165                  /* Check for 0..9,Aa-Zz */
    166                  if (!isalnum(c))
   \   00000092   0x4658             MOV      R0,R11
   \   00000094   0x.... 0x....      BL       isalnum
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD102             BNE.N    ??strtoul_16
    167                  {
    168                      err = 1;
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0x9000             STR      R0,[SP, #+0]
    169                      break;
   \   000000A0   0xE023             B.N      ??strtoul_15
    170                  }
    171          
    172                  /* Convert int8 to num in 0..36 */
    173                  if (isdigit(c))
   \                     ??strtoul_16: (+1)
   \   000000A2   0x4658             MOV      R0,R11
   \   000000A4   0x.... 0x....      BL       isdigit
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD002             BEQ.N    ??strtoul_17
    174                  {
    175                      c = c - '0';
   \   000000AC   0xF1BB 0x0B30      SUBS     R11,R11,#+48
   \   000000B0   0xE009             B.N      ??strtoul_18
    176                  }
    177                  else
    178                  {
    179                      if (isupper(c))
   \                     ??strtoul_17: (+1)
   \   000000B2   0x4658             MOV      R0,R11
   \   000000B4   0x.... 0x....      BL       isupper
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD002             BEQ.N    ??strtoul_19
    180                      {
    181                          c = c - 'A' + 10;
   \   000000BC   0xF1BB 0x0B37      SUBS     R11,R11,#+55
   \   000000C0   0xE001             B.N      ??strtoul_18
    182                      }
    183                      else
    184                      {
    185                          c = c - 'a' + 10;
   \                     ??strtoul_19: (+1)
   \   000000C2   0xF1BB 0x0B57      SUBS     R11,R11,#+87
    186                      }
    187                  }
    188          
    189                  /* check c against base */
    190                  if (c >= base)
   \                     ??strtoul_18: (+1)
   \   000000C6   0x45B3             CMP      R11,R6
   \   000000C8   0xDB02             BLT.N    ??strtoul_20
    191                  {
    192                      err = 1;
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0x9000             STR      R0,[SP, #+0]
    193                      break;
   \   000000CE   0xE00C             B.N      ??strtoul_15
    194                  }
    195          
    196                  if (neg)
   \                     ??strtoul_20: (+1)
   \   000000D0   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000D4   0xD004             BEQ.N    ??strtoul_21
    197                  {
    198                      rvalue = (rvalue * base) - c;
   \   000000D6   0xFB06 0xF007      MUL      R0,R6,R7
   \   000000DA   0xEBB0 0x070B      SUBS     R7,R0,R11
   \   000000DE   0xE001             B.N      ??strtoul_22
    199                  }
    200                  else
    201                  {
    202                      rvalue = (rvalue * base) + c;
   \                     ??strtoul_21: (+1)
   \   000000E0   0xFB06 0xB707      MLA      R7,R6,R7,R11
    203                  }
    204              }
   \                     ??strtoul_22: (+1)
   \   000000E4   0xF119 0x0901      ADDS     R9,R9,#+1
   \   000000E8   0xE7CD             B.N      ??strtoul_14
    205          
    206              /* Upon exit, endp points to the character at which valid info */
    207              /* STOPS.  No chars including and beyond endp are used.        */
    208          
    209              if (ptr != NULL)
   \                     ??strtoul_15: (+1)
   \   000000EA   0x2D00             CMP      R5,#+0
   \   000000EC   0xD001             BEQ.N    ??strtoul_23
    210                  *ptr = endp;
   \   000000EE   0xF8C5 0x9000      STR      R9,[R5, #+0]
    211          
    212              if (err)
   \                     ??strtoul_23: (+1)
   \   000000F2   0x9800             LDR      R0,[SP, #+0]
   \   000000F4   0x2800             CMP      R0,#+0
   \   000000F6   0xD004             BEQ.N    ??strtoul_24
    213              {
    214                  if (ptr != NULL)
   \   000000F8   0x2D00             CMP      R5,#+0
   \   000000FA   0xD000             BEQ.N    ??strtoul_25
    215                      *ptr = str;
   \   000000FC   0x602C             STR      R4,[R5, #+0]
    216                  
    217                  return 0;
   \                     ??strtoul_25: (+1)
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0xE000             B.N      ??strtoul_3
    218              }
    219              else
    220              {
    221                  return rvalue;
   \                     ??strtoul_24: (+1)
   \   00000102   0x0038             MOVS     R0,R7
   \                     ??strtoul_3: (+1)
   \   00000104   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    222              }
    223          }
    224          
    225          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    226          int strlen (const int8 *str)
    227          {
   \                     strlen: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    228              int8 *s = (int8 *)str;
   \   00000002   0x000A             MOVS     R2,R1
    229              int len = 0;
   \   00000004   0x2300             MOVS     R3,#+0
    230          
    231              if (s == NULL)
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD101             BNE.N    ??strlen_0
    232                  return 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE008             B.N      ??strlen_1
    233          
    234              while (*s++ != '\0')
   \                     ??strlen_0: (+1)
   \   0000000E   0x0010             MOVS     R0,R2
   \   00000010   0x1C42             ADDS     R2,R0,#+1
   \   00000012   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD001             BEQ.N    ??strlen_2
    235                  ++len;
   \   0000001A   0x1C5B             ADDS     R3,R3,#+1
   \   0000001C   0xE7F7             B.N      ??strlen_0
    236          
    237              return len;
   \                     ??strlen_2: (+1)
   \   0000001E   0x0018             MOVS     R0,R3
   \                     ??strlen_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
    238          }
    239          
    240          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    241          int8 * strcat (int8 *dest, const int8 *src)
    242          {
   \                     strcat: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    243              int8 *dp;
    244              int8 *sp = (int8 *)src;
   \   00000006   0x002F             MOVS     R7,R5
    245          
    246              if ((dest != NULL) && (src != NULL))
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD011             BEQ.N    ??strcat_0
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xD00F             BEQ.N    ??strcat_0
    247              {
    248                  dp = &dest[strlen(dest)];
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       strlen
   \   00000016   0x1900             ADDS     R0,R0,R4
   \   00000018   0x0006             MOVS     R6,R0
    249          
    250                  while (*sp != '\0')
   \                     ??strcat_1: (+1)
   \   0000001A   0xF997 0x0000      LDRSB    R0,[R7, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD004             BEQ.N    ??strcat_2
    251                  {
    252                      *dp++ = *sp++;
   \   00000022   0x7838             LDRB     R0,[R7, #+0]
   \   00000024   0x7030             STRB     R0,[R6, #+0]
   \   00000026   0x1C7F             ADDS     R7,R7,#+1
   \   00000028   0x1C76             ADDS     R6,R6,#+1
   \   0000002A   0xE7F6             B.N      ??strcat_1
    253                  }
    254                  *dp = '\0';
   \                     ??strcat_2: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x7030             STRB     R0,[R6, #+0]
    255              }
    256              return dest;
   \                     ??strcat_0: (+1)
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    257          }
    258          
    259          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    260          int8 * strncat (int8 *dest, const int8 *src, int n)
    261          {
   \                     strncat: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x4690             MOV      R8,R2
    262              int8 *dp;
    263              int8 *sp = (int8 *)src;
   \   0000000A   0x002F             MOVS     R7,R5
    264          
    265              if ((dest != NULL) && (src != NULL) && (n > 0))
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD019             BEQ.N    ??strncat_0
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD017             BEQ.N    ??strncat_0
   \   00000014   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000018   0xDB14             BLT.N    ??strncat_0
    266              {
    267                  dp = &dest[strlen(dest)];
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       strlen
   \   00000020   0x1900             ADDS     R0,R0,R4
   \   00000022   0x0006             MOVS     R6,R0
    268          
    269                  while ((*sp != '\0') && (n-- > 0))
   \                     ??strncat_1: (+1)
   \   00000024   0xF997 0x0000      LDRSB    R0,[R7, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD009             BEQ.N    ??strncat_2
   \   0000002C   0x4640             MOV      R0,R8
   \   0000002E   0xF1B0 0x0801      SUBS     R8,R0,#+1
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xDB04             BLT.N    ??strncat_2
    270                  {
    271                      *dp++ = *sp++;
   \   00000036   0x7838             LDRB     R0,[R7, #+0]
   \   00000038   0x7030             STRB     R0,[R6, #+0]
   \   0000003A   0x1C7F             ADDS     R7,R7,#+1
   \   0000003C   0x1C76             ADDS     R6,R6,#+1
   \   0000003E   0xE7F1             B.N      ??strncat_1
    272                  }
    273                  *dp = '\0';
   \                     ??strncat_2: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x7030             STRB     R0,[R6, #+0]
    274              }
    275              return dest;
   \                     ??strncat_0: (+1)
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    276          }
    277          
    278          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    279          int8 * strcpy (int8 *dest, const int8 *src)
    280          {
   \                     strcpy: (+1)
   \   00000000   0xB410             PUSH     {R4}
    281              int8 *dp = (int8 *)dest;
   \   00000002   0x0002             MOVS     R2,R0
    282              int8 *sp = (int8 *)src;
   \   00000004   0x000B             MOVS     R3,R1
    283          
    284              if ((dest != NULL) && (src != NULL))
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD00C             BEQ.N    ??strcpy_0
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD00A             BEQ.N    ??strcpy_0
    285              {
    286                  while (*sp != '\0')
   \                     ??strcpy_1: (+1)
   \   0000000E   0xF993 0x4000      LDRSB    R4,[R3, #+0]
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD004             BEQ.N    ??strcpy_2
    287                  {
    288                      *dp++ = *sp++;
   \   00000016   0x781C             LDRB     R4,[R3, #+0]
   \   00000018   0x7014             STRB     R4,[R2, #+0]
   \   0000001A   0x1C5B             ADDS     R3,R3,#+1
   \   0000001C   0x1C52             ADDS     R2,R2,#+1
   \   0000001E   0xE7F6             B.N      ??strcpy_1
    289                  }
    290                  *dp = '\0';
   \                     ??strcpy_2: (+1)
   \   00000020   0x2400             MOVS     R4,#+0
   \   00000022   0x7014             STRB     R4,[R2, #+0]
    291              }
    292              return dest;
   \                     ??strcpy_0: (+1)
   \   00000024   0xBC10             POP      {R4}
   \   00000026   0x4770             BX       LR               ;; return
    293          }
    294          
    295          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    296          int8 * strncpy (int8 *dest, const int8 *src, int n)
    297          {
   \                     strncpy: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    298              int8 *dp = (int8 *)dest;
   \   00000002   0x0003             MOVS     R3,R0
    299              int8 *sp = (int8 *)src;
   \   00000004   0x000C             MOVS     R4,R1
    300          
    301              if ((dest != NULL) && (src != NULL) && (n > 0))
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD012             BEQ.N    ??strncpy_0
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD010             BEQ.N    ??strncpy_0
   \   0000000E   0x2A01             CMP      R2,#+1
   \   00000010   0xDB0E             BLT.N    ??strncpy_0
    302              {
    303                  while ((*sp != '\0') && (n-- > 0))
   \                     ??strncpy_1: (+1)
   \   00000012   0xF994 0x5000      LDRSB    R5,[R4, #+0]
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD008             BEQ.N    ??strncpy_2
   \   0000001A   0x0015             MOVS     R5,R2
   \   0000001C   0x1E6A             SUBS     R2,R5,#+1
   \   0000001E   0x2D01             CMP      R5,#+1
   \   00000020   0xDB04             BLT.N    ??strncpy_2
    304                  {
    305                      *dp++ = *sp++;
   \   00000022   0x7825             LDRB     R5,[R4, #+0]
   \   00000024   0x701D             STRB     R5,[R3, #+0]
   \   00000026   0x1C64             ADDS     R4,R4,#+1
   \   00000028   0x1C5B             ADDS     R3,R3,#+1
   \   0000002A   0xE7F2             B.N      ??strncpy_1
    306                  }
    307                  *dp = '\0';
   \                     ??strncpy_2: (+1)
   \   0000002C   0x2500             MOVS     R5,#+0
   \   0000002E   0x701D             STRB     R5,[R3, #+0]
    308              }
    309              return dest;
   \                     ??strncpy_0: (+1)
   \   00000030   0xBC30             POP      {R4,R5}
   \   00000032   0x4770             BX       LR               ;; return
    310          }
    311          
    312          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    313          int strcmp (const int8 *s1, const int8 *s2)
    314          {
   \                     strcmp: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
    315              /* No checks for NULL */
    316              int8 *s1p = (int8 *)s1;
   \   00000004   0x0010             MOVS     R0,R2
    317              int8 *s2p = (int8 *)s2;
   \   00000006   0x000B             MOVS     R3,R1
    318          
    319              while (*s2p != '\0')
   \                     ??strcmp_0: (+1)
   \   00000008   0xF993 0x4000      LDRSB    R4,[R3, #+0]
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD008             BEQ.N    ??strcmp_1
    320              {
    321                  if (*s1p != *s2p)
   \   00000010   0xF990 0x4000      LDRSB    R4,[R0, #+0]
   \   00000014   0xF993 0x5000      LDRSB    R5,[R3, #+0]
   \   00000018   0x42AC             CMP      R4,R5
   \   0000001A   0xD102             BNE.N    ??strcmp_1
    322                      break;
    323          
    324                  ++s1p;
   \                     ??strcmp_2: (+1)
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
    325                  ++s2p;
   \   0000001E   0x1C5B             ADDS     R3,R3,#+1
   \   00000020   0xE7F2             B.N      ??strcmp_0
    326              }
    327              return (*s1p - *s2p);
   \                     ??strcmp_1: (+1)
   \   00000022   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000026   0xF993 0x3000      LDRSB    R3,[R3, #+0]
   \   0000002A   0x1AC0             SUBS     R0,R0,R3
   \   0000002C   0xBC30             POP      {R4,R5}
   \   0000002E   0x4770             BX       LR               ;; return
    328          }
    329          
    330          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    331          int strncmp (const int8 *s1, const int8 *s2, int n)
    332          {
   \                     strncmp: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0003             MOVS     R3,R0
    333              /* No checks for NULL */
    334              int8 *s1p = (int8 *)s1;
   \   00000004   0x001C             MOVS     R4,R3
    335              int8 *s2p = (int8 *)s2;
   \   00000006   0x000D             MOVS     R5,R1
    336          
    337              if (n <= 0)
   \   00000008   0x2A01             CMP      R2,#+1
   \   0000000A   0xDA01             BGE.N    ??strncmp_0
    338                  return 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE014             B.N      ??strncmp_1
    339          
    340              while (*s2p != '\0')
   \                     ??strncmp_0: (+1)
   \   00000010   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD00B             BEQ.N    ??strncmp_2
    341              {
    342                  if (*s1p != *s2p)
   \   00000018   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   0000001C   0xF995 0x6000      LDRSB    R6,[R5, #+0]
   \   00000020   0x42B0             CMP      R0,R6
   \   00000022   0xD105             BNE.N    ??strncmp_2
    343                      break;
    344          
    345                  if (--n == 0)
   \                     ??strncmp_3: (+1)
   \   00000024   0x1E52             SUBS     R2,R2,#+1
   \   00000026   0x2A00             CMP      R2,#+0
   \   00000028   0xD002             BEQ.N    ??strncmp_2
    346                      break;
    347          
    348                  ++s1p;
   \                     ??strncmp_4: (+1)
   \   0000002A   0x1C64             ADDS     R4,R4,#+1
    349                  ++s2p;
   \   0000002C   0x1C6D             ADDS     R5,R5,#+1
   \   0000002E   0xE7EF             B.N      ??strncmp_0
    350              }
    351              return (*s1p - *s2p);
   \                     ??strncmp_2: (+1)
   \   00000030   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000034   0xF995 0x4000      LDRSB    R4,[R5, #+0]
   \   00000038   0x1B00             SUBS     R0,R0,R4
   \                     ??strncmp_1: (+1)
   \   0000003A   0xBC70             POP      {R4-R6}
   \   0000003C   0x4770             BX       LR               ;; return
    352          }
    353          
    354          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    355          void * memcpy (void *dest, const void *src, unsigned n)
    356          {
   \                     memcpy: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    357              int longs, bytes;
    358              uint32 *dpl = (uint32 *)dest;
   \   00000002   0x0004             MOVS     R4,R0
    359              uint32 *spl = (uint32 *)src;
   \   00000004   0x000D             MOVS     R5,R1
    360              uint8  *dpb, *spb;
    361          
    362              if ((dest != NULL) && (src != NULL) && (n > 0))
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD027             BEQ.N    ??memcpy_0
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD025             BEQ.N    ??memcpy_0
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD023             BEQ.N    ??memcpy_0
    363              {
    364                  bytes = (n & 0x3);
   \   00000012   0xF012 0x0E03      ANDS     LR,R2,#0x3
   \   00000016   0x4673             MOV      R3,LR
    365                  longs = (n - bytes) >> 2;
   \   00000018   0xEBB2 0x0E03      SUBS     LR,R2,R3
   \   0000001C   0xEA5F 0x0E9E      LSRS     LR,LR,#+2
   \   00000020   0x46F4             MOV      R12,LR
    366              
    367                  while (longs--)
   \                     ??memcpy_1: (+1)
   \   00000022   0x46E6             MOV      LR,R12
   \   00000024   0xF1BE 0x0C01      SUBS     R12,LR,#+1
   \   00000028   0xF1BE 0x0F00      CMP      LR,#+0
   \   0000002C   0xD006             BEQ.N    ??memcpy_2
    368                      *dpl++ = *spl++;
   \   0000002E   0xF8D5 0xE000      LDR      LR,[R5, #+0]
   \   00000032   0xF8C4 0xE000      STR      LR,[R4, #+0]
   \   00000036   0x1D2D             ADDS     R5,R5,#+4
   \   00000038   0x1D24             ADDS     R4,R4,#+4
   \   0000003A   0xE7F2             B.N      ??memcpy_1
    369                  
    370                  dpb = (uint8 *)dpl;
   \                     ??memcpy_2: (+1)
   \   0000003C   0x0026             MOVS     R6,R4
    371                  spb = (uint8 *)spl;
   \   0000003E   0x002F             MOVS     R7,R5
    372                  
    373                  while (bytes--)
   \                     ??memcpy_3: (+1)
   \   00000040   0x469E             MOV      LR,R3
   \   00000042   0xF1BE 0x0301      SUBS     R3,LR,#+1
   \   00000046   0xF1BE 0x0F00      CMP      LR,#+0
   \   0000004A   0xD006             BEQ.N    ??memcpy_0
    374                      *dpb++ = *spb++;
   \   0000004C   0xF897 0xE000      LDRB     LR,[R7, #+0]
   \   00000050   0xF886 0xE000      STRB     LR,[R6, #+0]
   \   00000054   0x1C7F             ADDS     R7,R7,#+1
   \   00000056   0x1C76             ADDS     R6,R6,#+1
   \   00000058   0xE7F2             B.N      ??memcpy_3
    375              }
    376              return dest;
   \                     ??memcpy_0: (+1)
   \   0000005A   0xBDF0             POP      {R4-R7,PC}       ;; return
    377          }
    378          
    379          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    380          void * memset (void *s, int c, unsigned n)
    381          {
   \                     memset: (+1)
   \   00000000   0xB410             PUSH     {R4}
    382              /* Not optimized, but very portable */
    383              uint8 *sp = (uint8 *)s;
   \   00000002   0x0003             MOVS     R3,R0
    384          
    385              if ((s != NULL) && (n > 0))
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD008             BEQ.N    ??memset_0
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD006             BEQ.N    ??memset_0
    386              {
    387                  while (n--)
   \                     ??memset_1: (+1)
   \   0000000C   0x0014             MOVS     R4,R2
   \   0000000E   0x1E62             SUBS     R2,R4,#+1
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD002             BEQ.N    ??memset_0
    388                  {
    389                      *sp++ = (uint8)c;
   \   00000014   0x7019             STRB     R1,[R3, #+0]
   \   00000016   0x1C5B             ADDS     R3,R3,#+1
   \   00000018   0xE7F8             B.N      ??memset_1
    390                  }
    391              }
    392              return s;
   \                     ??memset_0: (+1)
   \   0000001A   0xBC10             POP      {R4}
   \   0000001C   0x4770             BX       LR               ;; return
    393          }
    394          
    395          /****************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   isalnum
       0   isdigit
       0   isspace
       0   isupper
      20   memcpy
       4   memset
       8   strcasecmp
      24   strcat
        24   -> strlen
       8   strcmp
       4   strcpy
       0   strlen
      16   strncasecmp
      24   strncat
        24   -> strlen
      12   strncmp
       8   strncpy
      40   strtoul
        40   -> isalnum
        40   -> isdigit
        40   -> isspace
        40   -> isupper


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      34  isalnum
      18  isdigit
      18  isspace
      18  isupper
      92  memcpy
      30  memset
      82  strcasecmp
      52  strcat
      48  strcmp
      40  strcpy
      34  strlen
      88  strncasecmp
      74  strncat
      62  strncmp
      52  strncpy
     264  strtoul

 
 1 006 bytes in section .text
 
 1 006 bytes of CODE memory

Errors: none
Warnings: none
