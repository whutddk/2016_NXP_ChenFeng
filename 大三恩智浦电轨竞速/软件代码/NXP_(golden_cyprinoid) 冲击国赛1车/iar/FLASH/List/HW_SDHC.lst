###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.3.8024/W32 for ARM        16/Aug/2016  11:11:14
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\lib\LPLD\HW\HW_SDHC.c
#    Command line =  
#        E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\lib\LPLD\HW\HW_SDHC.c -D LPLD_K60
#        -lCN
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\FLASH\List\" -lB
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\FLASH\List\" -o
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\FLASH\Obj\" --no_cse --no_unroll --no_inline --no_code_motion
#        --no_tbaa --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        D:\IAR\arm\INC\c\DLib_Config_Normal.h -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\app\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\app\BSP\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\app\ITAC\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\app\CTL\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\app\MAIN\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\app\SENSOR\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\CPU\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\common\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\LPLD\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\LPLD\HW\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\LPLD\DEV\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\uCOS-II\Ports\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\uCOS-II\Source\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\FatFs\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\FatFs\option\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\USB\common\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\USB\driver\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\USB\descriptor\" -I
#        "E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\..\..\..\lib\USB\class\" -On -I D:\IAR\arm\CMSIS\Include\ -D
#        ARM_MATH_CM4
#    List file    =  
#        E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\FLASH\List\HW_SDHC.lst
#    Object file  =  
#        E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\project\NXP_(golden_cyprinoid)
#        1.9\iar\FLASH\Obj\HW_SDHC.o
#
###############################################################################

E:\飞思卡尔\新工程\LPLD_OSKinetis_V3\lib\LPLD\HW\HW_SDHC.c
      1          /**
      2           * @file HW_SDHC.c
      3           * @version 3.01[By LPLD]
      4           * @date 2013-10-21
      5           * @brief SDHC底层模块相关函数
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * 版权所有:北京拉普兰德电子技术有限公司
     10           * http://www.lpld.cn
     11           * mail:support@lpld.cn
     12           *
     13           * @par
     14           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     15           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     16           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     17           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     18           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     19           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     20           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。 
     21           *
     22           * 版权说明:
     23           *  SDHC模块驱动程序摘取自飞思卡尔MQX底层驱动，部分功能由拉普兰德修改。
     24           *  HW_SDHC.h及HW_SDHC.c内的代码版权归飞思卡尔公司享有。
     25           * 
     26           * 3.01-2013-10-21 修复低容量SD卡无法初始化BUG
     27           */
     28          #include "common.h"
     29          #include "HW_SDHC.h"
     30          
     31          //SD卡信息全局变量

   \                                 In section .bss, align 4
     32          SDCARD_STRUCT_PTR sdcard_ptr;
   \                     sdcard_ptr:
   \   00000000                      DS8 4
     33          
     34          /*
     35           * LPLD_SDHC_InitGPIO
     36           * 初始化SDHC模块相关的GPIO引脚,并使能SDHC寄存器时钟
     37           * 
     38           * 参数:
     39           *    init--PCR寄存器掩码
     40           *
     41           * 输出:
     42           *    无
     43           */

   \                                 In section .text, align 2, keep-with-next
     44          static void LPLD_SDHC_InitGPIO(uint32 init)
     45          {  
     46            PORTE->PCR[0] = init & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* SDHC.D1  */
   \                     LPLD_SDHC_InitGPIO: (+1)
   \   00000000   0xF240 0x4143      MOVW     R1,#+1091
   \   00000004   0x4001             ANDS     R1,R1,R0
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable8  ;; 0x4004d000
   \   0000000A   0x6011             STR      R1,[R2, #+0]
     47            PORTE->PCR[1] = init & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* SDHC.D0  */
   \   0000000C   0xF240 0x4143      MOVW     R1,#+1091
   \   00000010   0x4001             ANDS     R1,R1,R0
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable8_1  ;; 0x4004d004
   \   00000016   0x6011             STR      R1,[R2, #+0]
     48            PORTE->PCR[2] = init & (PORT_PCR_MUX(4) | PORT_PCR_DSE_MASK);                                          /* SDHC.CLK */
   \   00000018   0xF410 0x6188      ANDS     R1,R0,#0x440
   \   0000001C   0x.... 0x....      LDR.W    R2,??DataTable8_2  ;; 0x4004d008
   \   00000020   0x6011             STR      R1,[R2, #+0]
     49            PORTE->PCR[3] = init & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* SDHC.CMD */
   \   00000022   0xF240 0x4143      MOVW     R1,#+1091
   \   00000026   0x4001             ANDS     R1,R1,R0
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable8_3  ;; 0x4004d00c
   \   0000002C   0x6011             STR      R1,[R2, #+0]
     50            PORTE->PCR[4] = init & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* SDHC.D3  */
   \   0000002E   0xF240 0x4143      MOVW     R1,#+1091
   \   00000032   0x4001             ANDS     R1,R1,R0
   \   00000034   0x.... 0x....      LDR.W    R2,??DataTable8_4  ;; 0x4004d010
   \   00000038   0x6011             STR      R1,[R2, #+0]
     51            PORTE->PCR[5] = init & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* SDHC.D2  */
   \   0000003A   0xF240 0x4143      MOVW     R1,#+1091
   \   0000003E   0x4001             ANDS     R1,R1,R0
   \   00000040   0x.... 0x....      LDR.W    R2,??DataTable8_5  ;; 0x4004d014
   \   00000044   0x6011             STR      R1,[R2, #+0]
     52            
     53            SIM->SCGC3 |= SIM_SCGC3_SDHC_MASK; 
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable8_6  ;; 0x40048030
   \   0000004A   0x6809             LDR      R1,[R1, #+0]
   \   0000004C   0xF451 0x3100      ORRS     R1,R1,#0x20000
   \   00000050   0x.... 0x....      LDR.W    R2,??DataTable8_6  ;; 0x40048030
   \   00000054   0x6011             STR      R1,[R2, #+0]
     54          }
   \   00000056   0x4770             BX       LR               ;; return
     55          
     56          
     57          /*
     58           * LPLD_SDHC_SetBaudrate
     59           * 设置SDHC波特率
     60           * 
     61           * 参数:
     62           *    clock--模块输入时钟，即g_core_clock*1000，单位Hz
     63           *    baud--SDHC期望时钟频率，单位Hz
     64           *
     65           * 输出:
     66           *    无
     67           */

   \                                 In section .text, align 2, keep-with-next
     68          static void LPLD_SDHC_SetBaudrate(uint32 clock, uint32 baud)
     69          {
   \                     LPLD_SDHC_SetBaudrate: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
     70            uint32 pres, div, min, minpres = 0x80, mindiv = 0x0F;
   \   00000002   0x2380             MOVS     R3,#+128
   \   00000004   0x240F             MOVS     R4,#+15
     71            int32  val;
     72            
     73            //找到相近的分频因子
     74            min = (uint32)-1;
   \   00000006   0xF05F 0x3CFF      MOVS     R12,#-1
   \   0000000A   0x4662             MOV      R2,R12
     75            for (pres = 2; pres <= 256; pres <<= 1)
   \   0000000C   0xF05F 0x0C02      MOVS     R12,#+2
   \   00000010   0x4667             MOV      R7,R12
   \                     ??LPLD_SDHC_SetBaudrate_0: (+1)
   \   00000012   0xF5B7 0x7F80      CMP      R7,#+256
   \   00000016   0xD816             BHI.N    ??LPLD_SDHC_SetBaudrate_1
     76            {
     77              for (div = 1; div <= 16; div++)
   \   00000018   0xF05F 0x0C01      MOVS     R12,#+1
   \   0000001C   0x4666             MOV      R6,R12
   \                     ??LPLD_SDHC_SetBaudrate_2: (+1)
   \   0000001E   0x2E11             CMP      R6,#+17
   \   00000020   0xD20F             BCS.N    ??LPLD_SDHC_SetBaudrate_3
     78              {
     79                val = pres * div * baud - clock;
   \   00000022   0xFB06 0xFC07      MUL      R12,R6,R7
   \   00000026   0xFB01 0xFC0C      MUL      R12,R1,R12
   \   0000002A   0xEBBC 0x0C00      SUBS     R12,R12,R0
   \   0000002E   0x4665             MOV      R5,R12
     80                if (val >= 0)
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD404             BMI.N    ??LPLD_SDHC_SetBaudrate_4
     81                {
     82                  if (min > val)
   \   00000034   0x4295             CMP      R5,R2
   \   00000036   0xD202             BCS.N    ??LPLD_SDHC_SetBaudrate_4
     83                  {
     84                    min = val;
   \   00000038   0x002A             MOVS     R2,R5
     85                    minpres = pres;
   \   0000003A   0x003B             MOVS     R3,R7
     86                    mindiv = div;
   \   0000003C   0x0034             MOVS     R4,R6
     87                  }
     88                }
     89              }
   \                     ??LPLD_SDHC_SetBaudrate_4: (+1)
   \   0000003E   0x1C76             ADDS     R6,R6,#+1
   \   00000040   0xE7ED             B.N      ??LPLD_SDHC_SetBaudrate_2
     90            }
   \                     ??LPLD_SDHC_SetBaudrate_3: (+1)
   \   00000042   0x007F             LSLS     R7,R7,#+1
   \   00000044   0xE7E5             B.N      ??LPLD_SDHC_SetBaudrate_0
     91            
     92            //禁止SDHC模块时钟
     93            SDHC->SYSCTL &= (~ SDHC_SYSCTL_SDCLKEN_MASK);
   \                     ??LPLD_SDHC_SetBaudrate_1: (+1)
   \   00000046   0x.... 0x....      LDR.W    R12,??DataTable8_7  ;; 0x400b102c
   \   0000004A   0xF8DC 0xC000      LDR      R12,[R12, #+0]
   \   0000004E   0xF03C 0x0C08      BICS     R12,R12,#0x8
   \   00000052   0x.... 0x....      LDR.W    LR,??DataTable8_7  ;; 0x400b102c
   \   00000056   0xF8CE 0xC000      STR      R12,[LR, #+0]
     94            
     95            //修改分频因子
     96            div = SDHC->SYSCTL & (~ (SDHC_SYSCTL_DTOCV_MASK | SDHC_SYSCTL_SDCLKFS_MASK | SDHC_SYSCTL_DVS_MASK));
   \   0000005A   0x.... 0x....      LDR.W    R12,??DataTable8_7  ;; 0x400b102c
   \   0000005E   0xF8DC 0xC000      LDR      R12,[R12, #+0]
   \   00000062   0xF36F 0x1C13      BFC      R12,#+4,#+16
   \   00000066   0x4666             MOV      R6,R12
     97            SDHC->SYSCTL = div | (SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_SDCLKFS(minpres >> 1) | SDHC_SYSCTL_DVS(mindiv - 1));
   \   00000068   0xEA5F 0x1CC3      LSLS     R12,R3,#+7
   \   0000006C   0xF41C 0x4C7F      ANDS     R12,R12,#0xFF00
   \   00000070   0xEA5C 0x0C06      ORRS     R12,R12,R6
   \   00000074   0xF1B4 0x0E01      SUBS     LR,R4,#+1
   \   00000078   0xEA5F 0x1E0E      LSLS     LR,LR,#+4
   \   0000007C   0xF01E 0x0EF0      ANDS     LR,LR,#0xF0
   \   00000080   0xEA5E 0x0C0C      ORRS     R12,LR,R12
   \   00000084   0xF45C 0x2C60      ORRS     R12,R12,#0xE0000
   \   00000088   0x.... 0x....      LDR.W    LR,??DataTable8_7  ;; 0x400b102c
   \   0000008C   0xF8CE 0xC000      STR      R12,[LR, #+0]
     98            
     99            //等在时钟稳定
    100            while (0 == (SDHC->PRSSTAT & SDHC_PRSSTAT_SDSTB_MASK))
   \                     ??LPLD_SDHC_SetBaudrate_5: (+1)
   \   00000090   0x.... 0x....      LDR.W    R12,??DataTable8_8  ;; 0x400b1024
   \   00000094   0xF8DC 0xC000      LDR      R12,[R12, #+0]
   \   00000098   0xEA5F 0x7C0C      LSLS     R12,R12,#+28
   \   0000009C   0xD5F8             BPL.N    ??LPLD_SDHC_SetBaudrate_5
    101            {};
    102            
    103            //使能SDHC模块时钟
    104            SDHC->SYSCTL |= SDHC_SYSCTL_SDCLKEN_MASK;
   \   0000009E   0x.... 0x....      LDR.W    R12,??DataTable8_7  ;; 0x400b102c
   \   000000A2   0xF8DC 0xC000      LDR      R12,[R12, #+0]
   \   000000A6   0xF05C 0x0C08      ORRS     R12,R12,#0x8
   \   000000AA   0x.... 0x....      LDR.W    LR,??DataTable8_7  ;; 0x400b102c
   \   000000AE   0xF8CE 0xC000      STR      R12,[LR, #+0]
    105            SDHC->IRQSTAT |= SDHC_IRQSTAT_DTOE_MASK;
   \   000000B2   0x.... 0x....      LDR.W    R12,??DataTable9  ;; 0x400b1030
   \   000000B6   0xF8DC 0xC000      LDR      R12,[R12, #+0]
   \   000000BA   0xF45C 0x1C80      ORRS     R12,R12,#0x100000
   \   000000BE   0x.... 0x....      LDR.W    LR,??DataTable9  ;; 0x400b1030
   \   000000C2   0xF8CE 0xC000      STR      R12,[LR, #+0]
    106          }
   \   000000C6   0xBDF0             POP      {R4-R7,PC}       ;; return
    107          
    108          /*
    109           * LPLD_SDHC_IsRunning
    110           * 获取SDHC模块运行状态
    111           * 
    112           * 参数:
    113           *    无
    114           *
    115           * 输出:
    116           *    TRUE--正在运行
    117           *    FALSE--停止运行
    118           */

   \                                 In section .text, align 2, keep-with-next
    119          static boolean LPLD_SDHC_IsRunning(void)
    120          {
    121            return (0 != (SDHC->PRSSTAT & (SDHC_PRSSTAT_RTA_MASK | SDHC_PRSSTAT_WTA_MASK | SDHC_PRSSTAT_DLA_MASK | SDHC_PRSSTAT_CDIHB_MASK | SDHC_PRSSTAT_CIHB_MASK)));
   \                     LPLD_SDHC_IsRunning: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable8_8  ;; 0x400b1024
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF240 0x3107      MOVW     R1,#+775
   \   0000000A   0x4208             TST      R0,R1
   \   0000000C   0xD001             BEQ.N    ??LPLD_SDHC_IsRunning_0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??LPLD_SDHC_IsRunning_1
   \                     ??LPLD_SDHC_IsRunning_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \                     ??LPLD_SDHC_IsRunning_1: (+1)
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
    122          }
    123          
    124          /*
    125           * LPLD_SDHC_WaitStatus
    126           * 等待指定状态标志位置位
    127           * 
    128           * 参数:
    129           *    mask--状态标志位掩码
    130           *
    131           * 输出:
    132           *    状态标志
    133           */

   \                                 In section .text, align 2, keep-with-next
    134          static uint32 LPLD_SDHC_WaitStatus(uint32 mask)
    135          {
   \                     LPLD_SDHC_WaitStatus: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    136            uint32 result;
    137            do
    138            {
    139              result = SDHC->IRQSTAT & mask;
   \                     ??LPLD_SDHC_WaitStatus_0: (+1)
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable9  ;; 0x400b1030
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0x400A             ANDS     R2,R1,R2
   \   0000000A   0x0010             MOVS     R0,R2
    140            }
    141            while (0 == result);
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD0F8             BEQ.N    ??LPLD_SDHC_WaitStatus_0
    142            return result;
   \   00000010   0x4770             BX       LR               ;; return
    143          }
    144          
    145          /*
    146           * LPLD_SDHC_Init
    147           * SDHC模块初始化函数
    148           * 
    149           * 参数:
    150           *    coreClk--系y主频，单位Hz
    151           *    baud--SDHC期望时钟频率，单位Hz
    152           *
    153           * 输出:
    154           *    SDHCSTA_OK--状态正常
    155           *    SDHCSTA_NOINIT--驱动未初始化
    156           *    SDHCSTA_NODISK--为插入卡
    157           *    SDHCSTA_PROTECT--卡写保护
    158           */

   \                                 In section .text, align 2, keep-with-next
    159          static SDHCRES LPLD_SDHC_Init(uint32 coreClk, uint32 baud)
    160          {
   \                     LPLD_SDHC_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    161            
    162            sdcard_ptr->CARD = ESDHC_CARD_NONE;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0x6108             STR      R0,[R1, #+16]
    163            
    164            //禁用GPIO的SDHC复用功能
    165            LPLD_SDHC_InitGPIO (0);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      BL       LPLD_SDHC_InitGPIO
    166            
    167            //复位SDHC模块
    168            SDHC->SYSCTL = SDHC_SYSCTL_RSTA_MASK | SDHC_SYSCTL_SDCLKFS(0x80);
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable8_9  ;; 0x1008000
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable8_7  ;; 0x400b102c
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    169            while (SDHC->SYSCTL & SDHC_SYSCTL_RSTA_MASK)
   \                     ??LPLD_SDHC_Init_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable8_7  ;; 0x400b102c
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x01C0             LSLS     R0,R0,#+7
   \   00000028   0xD4FA             BMI.N    ??LPLD_SDHC_Init_0
    170            { };
    171            
    172            //初始化寄存器值
    173            SDHC->VENDOR = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable8_10  ;; 0x400b10c0
   \   00000030   0x6008             STR      R0,[R1, #+0]
    174            SDHC->BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(512);
   \   00000032   0xF45F 0x3081      MOVS     R0,#+66048
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable8_11  ;; 0x400b1004
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    175            SDHC->PROCTL = SDHC_PROCTL_EMODE(ESDHC_PROCTL_EMODE_LITTLE) | SDHC_PROCTL_D3CD_MASK;
   \   0000003C   0x2028             MOVS     R0,#+40
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x400b1028
   \   00000042   0x6008             STR      R0,[R1, #+0]
    176            SDHC->WML = SDHC_WML_RDWML(2) | SDHC_WML_WRWML(1);
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable8_12  ;; 0x10002
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable8_13  ;; 0x400b1044
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    177            
    178            //设置SDHC初始化时钟，最好不要超过400kHz
    179            LPLD_SDHC_SetBaudrate (coreClk, baud);
   \   0000004E   0x0029             MOVS     R1,R5
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       LPLD_SDHC_SetBaudrate
    180            
    181            //等待
    182            while (SDHC->PRSSTAT & (SDHC_PRSSTAT_CIHB_MASK | SDHC_PRSSTAT_CDIHB_MASK))
   \                     ??LPLD_SDHC_Init_1: (+1)
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable8_8  ;; 0x400b1024
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0xF010 0x0F03      TST      R0,#0x3
   \   00000060   0xD1F9             BNE.N    ??LPLD_SDHC_Init_1
    183            { };
    184            
    185            //使能GPIO的SDHC复用
    186            LPLD_SDHC_InitGPIO (0xFFFF);
   \   00000062   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000066   0x.... 0x....      BL       LPLD_SDHC_InitGPIO
    187            
    188            //使能各种请求
    189            SDHC->IRQSTAT = 0xFFFF;
   \   0000006A   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x400b1030
   \   00000072   0x6008             STR      R0,[R1, #+0]
    190            SDHC->IRQSTATEN = SDHC_IRQSTATEN_DEBESEN_MASK | SDHC_IRQSTATEN_DCESEN_MASK | SDHC_IRQSTATEN_DTOESEN_MASK
    191              | SDHC_IRQSTATEN_CIESEN_MASK | SDHC_IRQSTATEN_CEBESEN_MASK | SDHC_IRQSTATEN_CCESEN_MASK | SDHC_IRQSTATEN_CTOESEN_MASK
    192                | SDHC_IRQSTATEN_BRRSEN_MASK | SDHC_IRQSTATEN_BWRSEN_MASK | SDHC_IRQSTATEN_CRMSEN_MASK
    193                  | SDHC_IRQSTATEN_TCSEN_MASK | SDHC_IRQSTATEN_CCSEN_MASK;
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable8_14  ;; 0x7f00b3
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable8_15  ;; 0x400b1034
   \   0000007C   0x6008             STR      R0,[R1, #+0]
    194            
    195            //等待80个初始时钟
    196            SDHC->SYSCTL |= SDHC_SYSCTL_INITA_MASK;
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable8_7  ;; 0x400b102c
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable8_7  ;; 0x400b102c
   \   0000008C   0x6008             STR      R0,[R1, #+0]
    197            while (SDHC->SYSCTL & SDHC_SYSCTL_INITA_MASK)
   \                     ??LPLD_SDHC_Init_2: (+1)
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable8_7  ;; 0x400b102c
   \   00000092   0x6800             LDR      R0,[R0, #+0]
   \   00000094   0x0100             LSLS     R0,R0,#+4
   \   00000096   0xD4FA             BMI.N    ??LPLD_SDHC_Init_2
    198            { };
    199            
    200            //检查卡是否插入
    201            if (SDHC->PRSSTAT & SDHC_PRSSTAT_CINS_MASK)
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable8_8  ;; 0x400b1024
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x03C0             LSLS     R0,R0,#+15
   \   000000A0   0xD505             BPL.N    ??LPLD_SDHC_Init_3
    202            {
    203              sdcard_ptr->CARD = ESDHC_CARD_UNKNOWN;
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   000000A8   0x6809             LDR      R1,[R1, #+0]
   \   000000AA   0x6108             STR      R0,[R1, #+16]
   \   000000AC   0xE004             B.N      ??LPLD_SDHC_Init_4
    204            }
    205            else
    206            {
    207              sdcard_ptr->STATUS = SDHCSTA_NODISK;
   \                     ??LPLD_SDHC_Init_3: (+1)
   \   000000AE   0x2002             MOVS     R0,#+2
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   000000B4   0x6809             LDR      R1,[R1, #+0]
   \   000000B6   0x6148             STR      R0,[R1, #+20]
    208            }
    209            SDHC->IRQSTAT |= SDHC_IRQSTAT_CRM_MASK;
   \                     ??LPLD_SDHC_Init_4: (+1)
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x400b1030
   \   000000C6   0x6008             STR      R0,[R1, #+0]
    210            
    211            return SDHCRES_OK;
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    212          }
    213          
    214          /*
    215           * LPLD_SDHC_SendCommand
    216           * 向SD卡发送指定CMD命令
    217           * 
    218           * 参数:
    219           *    command--SDHC命令信息结构体
    220           *
    221           * 输出:
    222           *    SDHCRES--磁盘功能返回值
    223           */

   \                                 In section .text, align 2, keep-with-next
    224          static SDHCRES LPLD_SDHC_SendCommand(ESDHC_COMMAND_STRUCT_PTR command)
    225          {
   \                     LPLD_SDHC_SendCommand: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    226            uint32 xfertyp;
    227            uint32 blkattr;
    228            
    229            //检查命令
    230            xfertyp = command->COMMAND;
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x0006             MOVS     R6,R0
    231            
    232            if (ESDHC_XFERTYP_CMDTYP_RESUME == ((xfertyp & SDHC_XFERTYP_CMDTYP_MASK) >> SDHC_XFERTYP_CMDTYP_SHIFT))
   \   00000008   0xF3C6 0x5081      UBFX     R0,R6,#+22,#+2
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??LPLD_SDHC_SendCommand_0
    233            {
    234              //恢复类型命令必须设置DPSEL位
    235              xfertyp |= SDHC_XFERTYP_DPSEL_MASK;
   \   00000010   0xF456 0x1600      ORRS     R6,R6,#0x200000
    236            }
    237            
    238            if ((0 != command->BLOCKS) && (0 != command->BLOCKSIZE))
   \                     ??LPLD_SDHC_SendCommand_0: (+1)
   \   00000014   0x68A0             LDR      R0,[R4, #+8]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD020             BEQ.N    ??LPLD_SDHC_SendCommand_1
   \   0000001A   0x68E0             LDR      R0,[R4, #+12]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD01D             BEQ.N    ??LPLD_SDHC_SendCommand_1
    239            {
    240              xfertyp |= SDHC_XFERTYP_DPSEL_MASK;
   \   00000020   0xF456 0x1600      ORRS     R6,R6,#0x200000
    241              if (command->BLOCKS != 1)
   \   00000024   0x68A0             LDR      R0,[R4, #+8]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD001             BEQ.N    ??LPLD_SDHC_SendCommand_2
    242              {
    243                //多块传输
    244                xfertyp |= SDHC_XFERTYP_MSBSEL_MASK;
   \   0000002A   0xF056 0x0620      ORRS     R6,R6,#0x20
    245              }
    246              if ((uint32)-1 == command->BLOCKS)
   \                     ??LPLD_SDHC_SendCommand_2: (+1)
   \   0000002E   0x68A0             LDR      R0,[R4, #+8]
   \   00000030   0xF110 0x0F01      CMN      R0,#+1
   \   00000034   0xD108             BNE.N    ??LPLD_SDHC_SendCommand_3
    247              {
    248                //大量传输
    249                blkattr = SDHC_BLKATTR_BLKSIZE(command->BLOCKSIZE) | SDHC_BLKATTR_BLKCNT(0xFFFF);
   \   00000036   0x68E0             LDR      R0,[R4, #+12]
   \   00000038   0x04C0             LSLS     R0,R0,#+19       ;; ZeroExtS R0,R0,#+19,#+19
   \   0000003A   0x0CC0             LSRS     R0,R0,#+19
   \   0000003C   0xF040 0x407F      ORR      R0,R0,#0xFF000000
   \   00000040   0xF450 0x007F      ORRS     R0,R0,#0xFF0000
   \   00000044   0x0005             MOVS     R5,R0
   \   00000046   0xE00B             B.N      ??LPLD_SDHC_SendCommand_4
    250              }
    251              else
    252              {
    253                blkattr = SDHC_BLKATTR_BLKSIZE(command->BLOCKSIZE) | SDHC_BLKATTR_BLKCNT(command->BLOCKS);
   \                     ??LPLD_SDHC_SendCommand_3: (+1)
   \   00000048   0x68E0             LDR      R0,[R4, #+12]
   \   0000004A   0x04C0             LSLS     R0,R0,#+19       ;; ZeroExtS R0,R0,#+19,#+19
   \   0000004C   0x0CC0             LSRS     R0,R0,#+19
   \   0000004E   0x68A1             LDR      R1,[R4, #+8]
   \   00000050   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   00000054   0x0005             MOVS     R5,R0
    254                xfertyp |= SDHC_XFERTYP_BCEN_MASK;
   \   00000056   0xF056 0x0602      ORRS     R6,R6,#0x2
   \   0000005A   0xE001             B.N      ??LPLD_SDHC_SendCommand_4
    255              }
    256            }
    257            else
    258            {
    259              blkattr = 0;
   \                     ??LPLD_SDHC_SendCommand_1: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x0005             MOVS     R5,R0
    260            }
    261            
    262            //卡移除状态清除
    263            SDHC->IRQSTAT |= SDHC_IRQSTAT_CRM_MASK;
   \                     ??LPLD_SDHC_SendCommand_4: (+1)
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x400b1030
   \   0000006E   0x6008             STR      R0,[R1, #+0]
    264            
    265            //等待CMD线空闲
    266            while (SDHC->PRSSTAT & SDHC_PRSSTAT_CIHB_MASK)
   \                     ??LPLD_SDHC_SendCommand_5: (+1)
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable8_8  ;; 0x400b1024
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x07C0             LSLS     R0,R0,#+31
   \   00000078   0xD4FA             BMI.N    ??LPLD_SDHC_SendCommand_5
    267            { };
    268            
    269            //初始化命令
    270            SDHC->CMDARG = command->ARGUMENT;
   \   0000007A   0x6860             LDR      R0,[R4, #+4]
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1008
   \   00000080   0x6008             STR      R0,[R1, #+0]
    271            SDHC->BLKATTR = blkattr;
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable8_11  ;; 0x400b1004
   \   00000086   0x6005             STR      R5,[R0, #+0]
    272            SDHC->DSADDR = 0;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable10_1  ;; 0x400b1000
   \   0000008E   0x6008             STR      R0,[R1, #+0]
    273            
    274            //发送命令
    275            SDHC->XFERTYP = xfertyp;
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x400b100c
   \   00000094   0x6006             STR      R6,[R0, #+0]
    276            
    277            //等待响应
    278            if (LPLD_SDHC_WaitStatus (SDHC_IRQSTAT_CIE_MASK | SDHC_IRQSTAT_CEBE_MASK | SDHC_IRQSTAT_CCE_MASK | SDHC_IRQSTAT_CC_MASK) != SDHC_IRQSTAT_CC_MASK)
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0xe0001
   \   0000009A   0x.... 0x....      BL       LPLD_SDHC_WaitStatus
   \   0000009E   0x2801             CMP      R0,#+1
   \   000000A0   0xD00B             BEQ.N    ??LPLD_SDHC_SendCommand_6
    279            {
    280              SDHC->IRQSTAT |= SDHC_IRQSTAT_CTOE_MASK | SDHC_IRQSTAT_CIE_MASK | SDHC_IRQSTAT_CEBE_MASK | SDHC_IRQSTAT_CCE_MASK | SDHC_IRQSTAT_CC_MASK;
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   000000A6   0x6800             LDR      R0,[R0, #+0]
   \   000000A8   0xF440 0x2070      ORR      R0,R0,#0xF0000
   \   000000AC   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x400b1030
   \   000000B4   0x6008             STR      R0,[R1, #+0]
    281              return SDHCRES_ERROR;
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0xE043             B.N      ??LPLD_SDHC_SendCommand_7
    282            }
    283            
    284            //检查卡是否移除
    285            if (SDHC->IRQSTAT & SDHC_IRQSTAT_CRM_MASK)
   \                     ??LPLD_SDHC_SendCommand_6: (+1)
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   000000BE   0x6800             LDR      R0,[R0, #+0]
   \   000000C0   0x0600             LSLS     R0,R0,#+24
   \   000000C2   0xD50E             BPL.N    ??LPLD_SDHC_SendCommand_8
    286            {
    287              SDHC->IRQSTAT |= SDHC_IRQSTAT_CTOE_MASK | SDHC_IRQSTAT_CC_MASK;
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   000000C8   0x6800             LDR      R0,[R0, #+0]
   \   000000CA   0xF050 0x1001      ORRS     R0,R0,#0x10001
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x400b1030
   \   000000D2   0x6008             STR      R0,[R1, #+0]
    288              sdcard_ptr->STATUS = SDHCSTA_NODISK;
   \   000000D4   0x2002             MOVS     R0,#+2
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   000000DA   0x6809             LDR      R1,[R1, #+0]
   \   000000DC   0x6148             STR      R0,[R1, #+20]
    289              return SDHCRES_NOTRDY;
   \   000000DE   0x2003             MOVS     R0,#+3
   \   000000E0   0xE02F             B.N      ??LPLD_SDHC_SendCommand_7
    290            }
    291            
    292            //获取响应
    293            if (SDHC->IRQSTAT & SDHC_IRQSTAT_CTOE_MASK)
   \                     ??LPLD_SDHC_SendCommand_8: (+1)
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   000000E6   0x6800             LDR      R0,[R0, #+0]
   \   000000E8   0x03C0             LSLS     R0,R0,#+15
   \   000000EA   0xD509             BPL.N    ??LPLD_SDHC_SendCommand_9
    294            {
    295              SDHC->IRQSTAT |= SDHC_IRQSTAT_CTOE_MASK | SDHC_IRQSTAT_CC_MASK;
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   000000F0   0x6800             LDR      R0,[R0, #+0]
   \   000000F2   0xF050 0x1001      ORRS     R0,R0,#0x10001
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x400b1030
   \   000000FA   0x6008             STR      R0,[R1, #+0]
    296              return SDHCRES_NONRSPNS;
   \   000000FC   0x2005             MOVS     R0,#+5
   \   000000FE   0xE020             B.N      ??LPLD_SDHC_SendCommand_7
    297            }
    298            if ((xfertyp & SDHC_XFERTYP_RSPTYP_MASK) != SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_NO))
   \                     ??LPLD_SDHC_SendCommand_9: (+1)
   \   00000100   0xF416 0x3F40      TST      R6,#0x30000
   \   00000104   0xD014             BEQ.N    ??LPLD_SDHC_SendCommand_10
    299            {
    300              command->RESPONSE[0] = SDHC->CMDRSP[0];
   \   00000106   0x.... 0x....      LDR.W    R0,??DataTable10_4  ;; 0x400b1010
   \   0000010A   0x6800             LDR      R0,[R0, #+0]
   \   0000010C   0x6120             STR      R0,[R4, #+16]
    301              if ((xfertyp & SDHC_XFERTYP_RSPTYP_MASK) == SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_136))
   \   0000010E   0xF416 0x3040      ANDS     R0,R6,#0x30000
   \   00000112   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000116   0xD10B             BNE.N    ??LPLD_SDHC_SendCommand_10
    302              {
    303                command->RESPONSE[1] = SDHC->CMDRSP[1];
   \   00000118   0x.... 0x....      LDR.W    R0,??DataTable10_5  ;; 0x400b1014
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0x6160             STR      R0,[R4, #+20]
    304                command->RESPONSE[2] = SDHC->CMDRSP[2];
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable10_6  ;; 0x400b1018
   \   00000124   0x6800             LDR      R0,[R0, #+0]
   \   00000126   0x61A0             STR      R0,[R4, #+24]
    305                command->RESPONSE[3] = SDHC->CMDRSP[3];
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable10_7  ;; 0x400b101c
   \   0000012C   0x6800             LDR      R0,[R0, #+0]
   \   0000012E   0x61E0             STR      R0,[R4, #+28]
    306              }
    307            }
    308            SDHC->IRQSTAT |= SDHC_IRQSTAT_CC_MASK;
   \                     ??LPLD_SDHC_SendCommand_10: (+1)
   \   00000130   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   00000134   0x6800             LDR      R0,[R0, #+0]
   \   00000136   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000013A   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x400b1030
   \   0000013E   0x6008             STR      R0,[R1, #+0]
    309            
    310            return SDHCRES_OK;
   \   00000140   0x2000             MOVS     R0,#+0
   \                     ??LPLD_SDHC_SendCommand_7: (+1)
   \   00000142   0xBD70             POP      {R4-R6,PC}       ;; return
    311          }
    312          
    313          
    314          /*
    315           * LPLD_SDHC_IOC
    316           * SDHC模块其他控制服务函数
    317           * 
    318           * 参数:
    319           *    cmd--SDHC模块控制命令
    320           *    *param_ptr--控制参数
    321           *
    322           * 输出:
    323           *    SDHCRES--磁盘功能返回值
    324           */

   \                                 In section .text, align 2, keep-with-next
    325          SDHCRES LPLD_SDHC_IOC(uint32 cmd, void *param_ptr)
    326          {
   \                     LPLD_SDHC_IOC: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    327            
    328            ESDHC_COMMAND_STRUCT    command;
    329            boolean                 mem, io, mmc, ceata, mp, hc;
    330            int32                  val;
    331            SDHCRES                 result = SDHCRES_OK;
   \   0000000A   0xF05F 0x0900      MOVS     R9,#+0
    332            uint32 *             param32_ptr = param_ptr;
   \   0000000E   0x46AA             MOV      R10,R5
    333            
    334            switch (cmd)
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD015             BEQ.N    ??LPLD_SDHC_IOC_0
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xF000 0x81F9      BEQ.W    ??LPLD_SDHC_IOC_1
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xF000 0x82B0      BEQ.W    ??LPLD_SDHC_IOC_2
   \   00000022   0x2804             CMP      R0,#+4
   \   00000024   0xF000 0x81F8      BEQ.W    ??LPLD_SDHC_IOC_3
   \   00000028   0x2805             CMP      R0,#+5
   \   0000002A   0xF000 0x8215      BEQ.W    ??LPLD_SDHC_IOC_4
   \   0000002E   0x2806             CMP      R0,#+6
   \   00000030   0xF000 0x8238      BEQ.W    ??LPLD_SDHC_IOC_5
   \   00000034   0x2807             CMP      R0,#+7
   \   00000036   0xF000 0x8259      BEQ.W    ??LPLD_SDHC_IOC_6
   \   0000003A   0x2893             CMP      R0,#+147
   \   0000003C   0xF000 0x82E4      BEQ.W    ??LPLD_SDHC_IOC_7
   \   00000040   0xE2FE             B.N      ??LPLD_SDHC_IOC_8
    335            {
    336            case IO_IOCTL_ESDHC_INIT:  
    337              //初始化SDHC模块
    338              result = LPLD_SDHC_Init (g_core_clock*1000, 400000);
   \                     ??LPLD_SDHC_IOC_0: (+1)
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable10_8  ;; 0x61a80
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable10_9
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0xF44F 0x727A      MOV      R2,#+1000
   \   00000050   0x4350             MULS     R0,R2,R0
   \   00000052   0x.... 0x....      BL       LPLD_SDHC_Init
   \   00000056   0x4681             MOV      R9,R0
    339              if (SDHCRES_OK != result)
   \   00000058   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000005C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000060   0xF040 0x82F0      BNE.W    ??LPLD_SDHC_IOC_9
    340              {
    341                break;
    342              }
    343              
    344              mem = FALSE;
   \                     ??LPLD_SDHC_IOC_10: (+1)
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x0006             MOVS     R6,R0
    345              io = FALSE;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x0007             MOVS     R7,R0
    346              mmc = FALSE;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    347              ceata = FALSE;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xF88D 0x0002      STRB     R0,[SP, #+2]
    348              hc = FALSE;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x4680             MOV      R8,R0
    349              mp = FALSE;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    350              
    351              //CMD0 - 空闲命令，复位卡
    352              command.COMMAND = ESDHC_CMD0;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x9001             STR      R0,[SP, #+4]
    353              command.ARGUMENT = 0;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x9002             STR      R0,[SP, #+8]
    354              command.BLOCKS = 0;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x9003             STR      R0,[SP, #+12]
    355              result = LPLD_SDHC_SendCommand (&command);
   \   0000008E   0xA801             ADD      R0,SP,#+4
   \   00000090   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   00000094   0x4681             MOV      R9,R0
    356              if (result!=SDHCRES_OK)
   \   00000096   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000009A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000009E   0xD005             BEQ.N    ??LPLD_SDHC_IOC_11
    357              {
    358                sdcard_ptr->STATUS = SDHCSTA_NOINIT;
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   000000A6   0x6809             LDR      R1,[R1, #+0]
   \   000000A8   0x6148             STR      R0,[R1, #+20]
    359                break;
   \   000000AA   0xE2CB             B.N      ??LPLD_SDHC_IOC_9
    360              }
    361              
    362              //CMD8 - 发送接口状态，检查是否支持高容量
    363              command.COMMAND = ESDHC_CMD8;
   \                     ??LPLD_SDHC_IOC_11: (+1)
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable10_10  ;; 0x81a0000
   \   000000B0   0x9001             STR      R0,[SP, #+4]
    364              command.ARGUMENT = 0x000001AA;
   \   000000B2   0xF44F 0x70D5      MOV      R0,#+426
   \   000000B6   0x9002             STR      R0,[SP, #+8]
    365              command.BLOCKS = 0;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x9003             STR      R0,[SP, #+12]
    366              result = LPLD_SDHC_SendCommand (&command);
   \   000000BC   0xA801             ADD      R0,SP,#+4
   \   000000BE   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   000000C2   0x4681             MOV      R9,R0
    367              if (result==SDHCRES_ERROR)
   \   000000C4   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000C8   0xF1B9 0x0F01      CMP      R9,#+1
   \   000000CC   0xD105             BNE.N    ??LPLD_SDHC_IOC_12
    368              {
    369                sdcard_ptr->STATUS = SDHCSTA_NOINIT;
   \   000000CE   0x2001             MOVS     R0,#+1
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   000000D4   0x6809             LDR      R1,[R1, #+0]
   \   000000D6   0x6148             STR      R0,[R1, #+20]
    370                break;
   \   000000D8   0xE2B4             B.N      ??LPLD_SDHC_IOC_9
    371              }
    372              if (result == SDHCRES_OK)
   \                     ??LPLD_SDHC_IOC_12: (+1)
   \   000000DA   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000DE   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000E2   0xD10D             BNE.N    ??LPLD_SDHC_IOC_13
    373              {
    374                if (command.RESPONSE[0] != command.ARGUMENT)
   \   000000E4   0x9805             LDR      R0,[SP, #+20]
   \   000000E6   0x9902             LDR      R1,[SP, #+8]
   \   000000E8   0x4288             CMP      R0,R1
   \   000000EA   0xD007             BEQ.N    ??LPLD_SDHC_IOC_14
    375                {
    376                  sdcard_ptr->STATUS = SDHCSTA_NOINIT;
   \   000000EC   0x2001             MOVS     R0,#+1
   \   000000EE   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   000000F2   0x6809             LDR      R1,[R1, #+0]
   \   000000F4   0x6148             STR      R0,[R1, #+20]
    377                  result = SDHCRES_ERROR;
   \   000000F6   0x2001             MOVS     R0,#+1
   \   000000F8   0x4681             MOV      R9,R0
    378                  break;
   \   000000FA   0xE2A3             B.N      ??LPLD_SDHC_IOC_9
    379                }
    380                hc = TRUE;
   \                     ??LPLD_SDHC_IOC_14: (+1)
   \   000000FC   0x2001             MOVS     R0,#+1
   \   000000FE   0x4680             MOV      R8,R0
    381              }
    382              
    383              //CMD5 - 发送操作状态，测试IO
    384              command.COMMAND = ESDHC_CMD5;
   \                     ??LPLD_SDHC_IOC_13: (+1)
   \   00000100   0x.... 0x....      LDR.W    R0,??DataTable11  ;; 0x5020000
   \   00000104   0x9001             STR      R0,[SP, #+4]
    385              command.ARGUMENT = 0;
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0x9002             STR      R0,[SP, #+8]
    386              command.BLOCKS = 0;      
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0x9003             STR      R0,[SP, #+12]
    387              result = LPLD_SDHC_SendCommand (&command);
   \   0000010E   0xA801             ADD      R0,SP,#+4
   \   00000110   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   00000114   0x4681             MOV      R9,R0
    388              if (result==SDHCRES_ERROR)
   \   00000116   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000011A   0xF1B9 0x0F01      CMP      R9,#+1
   \   0000011E   0xD105             BNE.N    ??LPLD_SDHC_IOC_15
    389              {
    390                sdcard_ptr->STATUS = SDHCSTA_NOINIT;
   \   00000120   0x2001             MOVS     R0,#+1
   \   00000122   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   00000126   0x6809             LDR      R1,[R1, #+0]
   \   00000128   0x6148             STR      R0,[R1, #+20]
    391                break;
   \   0000012A   0xE28B             B.N      ??LPLD_SDHC_IOC_9
    392              }
    393              if (result == SDHCRES_OK)
   \                     ??LPLD_SDHC_IOC_15: (+1)
   \   0000012C   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000130   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000134   0xD133             BNE.N    ??LPLD_SDHC_IOC_16
    394              {
    395                if (((command.RESPONSE[0] >> 28) & 0x07) && (command.RESPONSE[0] & 0x300000))
   \   00000136   0x9805             LDR      R0,[SP, #+20]
   \   00000138   0xF3C0 0x7002      UBFX     R0,R0,#+28,#+3
   \   0000013C   0x2800             CMP      R0,#+0
   \   0000013E   0xD031             BEQ.N    ??LPLD_SDHC_IOC_17
   \   00000140   0x9805             LDR      R0,[SP, #+20]
   \   00000142   0xF410 0x1F40      TST      R0,#0x300000
   \   00000146   0xD02D             BEQ.N    ??LPLD_SDHC_IOC_17
    396                {
    397                  command.COMMAND = ESDHC_CMD5;
   \   00000148   0x.... 0x....      LDR.W    R0,??DataTable11  ;; 0x5020000
   \   0000014C   0x9001             STR      R0,[SP, #+4]
    398                  command.ARGUMENT = 0x300000;
   \   0000014E   0xF45F 0x1040      MOVS     R0,#+3145728
   \   00000152   0x9002             STR      R0,[SP, #+8]
    399                  command.BLOCKS = 0;
   \   00000154   0x2000             MOVS     R0,#+0
   \   00000156   0x9003             STR      R0,[SP, #+12]
    400                  val = 0;
   \   00000158   0x2000             MOVS     R0,#+0
   \   0000015A   0x4683             MOV      R11,R0
    401                  do
    402                  {
    403                    val++;
   \                     ??LPLD_SDHC_IOC_18: (+1)
   \   0000015C   0xF11B 0x0B01      ADDS     R11,R11,#+1
    404                    if (result = LPLD_SDHC_SendCommand (&command))
   \   00000160   0xA801             ADD      R0,SP,#+4
   \   00000162   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   00000166   0x4681             MOV      R9,R0
   \   00000168   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000016A   0x2800             CMP      R0,#+0
   \   0000016C   0xD105             BNE.N    ??LPLD_SDHC_IOC_19
    405                    {
    406                      break;
    407                    }
    408                  } while ((0 == (command.RESPONSE[0] & 0x80000000)) && (val < ESDHC_ALARM_FREQUENCY));
   \                     ??LPLD_SDHC_IOC_20: (+1)
   \   0000016E   0x9805             LDR      R0,[SP, #+20]
   \   00000170   0x2800             CMP      R0,#+0
   \   00000172   0xD402             BMI.N    ??LPLD_SDHC_IOC_19
   \   00000174   0xF1BB 0x0F64      CMP      R11,#+100
   \   00000178   0xDBF0             BLT.N    ??LPLD_SDHC_IOC_18
    409                  if (SDHCRES_OK != result)
   \                     ??LPLD_SDHC_IOC_19: (+1)
   \   0000017A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000017E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000182   0xF040 0x825F      BNE.W    ??LPLD_SDHC_IOC_9
    410                  {
    411                    break;
    412                  }
    413                  if (command.RESPONSE[0] & 0x80000000)
   \                     ??LPLD_SDHC_IOC_21: (+1)
   \   00000186   0x9805             LDR      R0,[SP, #+20]
   \   00000188   0x2800             CMP      R0,#+0
   \   0000018A   0xD501             BPL.N    ??LPLD_SDHC_IOC_22
    414                  {
    415                    io = TRUE;
   \   0000018C   0x2001             MOVS     R0,#+1
   \   0000018E   0x0007             MOVS     R7,R0
    416                  }
    417                  if (command.RESPONSE[0] & 0x08000000)
   \                     ??LPLD_SDHC_IOC_22: (+1)
   \   00000190   0x9805             LDR      R0,[SP, #+20]
   \   00000192   0x0100             LSLS     R0,R0,#+4
   \   00000194   0xD506             BPL.N    ??LPLD_SDHC_IOC_17
    418                  {
    419                    mp = TRUE;
   \   00000196   0x2001             MOVS     R0,#+1
   \   00000198   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000019C   0xE002             B.N      ??LPLD_SDHC_IOC_17
    420                  }
    421                }
    422              }
    423              else
    424              {
    425                mp = TRUE;
   \                     ??LPLD_SDHC_IOC_16: (+1)
   \   0000019E   0x2001             MOVS     R0,#+1
   \   000001A0   0xF88D 0x0000      STRB     R0,[SP, #+0]
    426              }
    427              
    428              if (mp)
   \                     ??LPLD_SDHC_IOC_17: (+1)
   \   000001A4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000001A8   0x2800             CMP      R0,#+0
   \   000001AA   0xF000 0x80D3      BEQ.W    ??LPLD_SDHC_IOC_23
    429              {
    430                //CMD55 - 特殊应用命令，检查MMC卡
    431                command.COMMAND = ESDHC_CMD55;
   \   000001AE   0x.... 0x....      LDR.W    R0,??DataTable11_1  ;; 0x371a0000
   \   000001B2   0x9001             STR      R0,[SP, #+4]
    432                command.ARGUMENT = 0;
   \   000001B4   0x2000             MOVS     R0,#+0
   \   000001B6   0x9002             STR      R0,[SP, #+8]
    433                command.BLOCKS = 0;
   \   000001B8   0x2000             MOVS     R0,#+0
   \   000001BA   0x9003             STR      R0,[SP, #+12]
    434                if ((result = LPLD_SDHC_SendCommand (&command))==SDHCRES_ERROR)
   \   000001BC   0xA801             ADD      R0,SP,#+4
   \   000001BE   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   000001C2   0x4681             MOV      R9,R0
   \   000001C4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001C6   0x2801             CMP      R0,#+1
   \   000001C8   0xF000 0x823C      BEQ.W    ??LPLD_SDHC_IOC_9
    435                {
    436                  break;
    437                }
    438                if (result == SDHCRES_NONRSPNS)
   \                     ??LPLD_SDHC_IOC_24: (+1)
   \   000001CC   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001D0   0xF1B9 0x0F05      CMP      R9,#+5
   \   000001D4   0xD15C             BNE.N    ??LPLD_SDHC_IOC_25
    439                {
    440                  //如果为MMC 或 CE-ATA 卡
    441                  io = FALSE;
   \   000001D6   0x2000             MOVS     R0,#+0
   \   000001D8   0x0007             MOVS     R7,R0
    442                  mem = FALSE;
   \   000001DA   0x2000             MOVS     R0,#+0
   \   000001DC   0x0006             MOVS     R6,R0
    443                  hc = FALSE;
   \   000001DE   0x2000             MOVS     R0,#+0
   \   000001E0   0x4680             MOV      R8,R0
    444                  
    445                  //CMD1 - 发送测试命令，检查高容量支持
    446                  command.COMMAND = ESDHC_CMD1;
   \   000001E2   0xF05F 0x7080      MOVS     R0,#+16777216
   \   000001E6   0x9001             STR      R0,[SP, #+4]
    447                  command.ARGUMENT = 0x40300000;
   \   000001E8   0x.... 0x....      LDR.W    R0,??DataTable11_2  ;; 0x40300000
   \   000001EC   0x9002             STR      R0,[SP, #+8]
    448                  command.BLOCKS = 0;
   \   000001EE   0x2000             MOVS     R0,#+0
   \   000001F0   0x9003             STR      R0,[SP, #+12]
    449                  if (result = LPLD_SDHC_SendCommand (&command))
   \   000001F2   0xA801             ADD      R0,SP,#+4
   \   000001F4   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   000001F8   0x4681             MOV      R9,R0
   \   000001FA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001FC   0x2800             CMP      R0,#+0
   \   000001FE   0xF040 0x8221      BNE.W    ??LPLD_SDHC_IOC_9
    450                  {
    451                    break;
    452                  }
    453                  if (0x20000000 == (command.RESPONSE[0] & 0x60000000))
   \                     ??LPLD_SDHC_IOC_26: (+1)
   \   00000202   0x9805             LDR      R0,[SP, #+20]
   \   00000204   0xF010 0x40C0      ANDS     R0,R0,#0x60000000
   \   00000208   0xF1B0 0x5F00      CMP      R0,#+536870912
   \   0000020C   0xD101             BNE.N    ??LPLD_SDHC_IOC_27
    454                  {
    455                    hc = TRUE;
   \   0000020E   0x2001             MOVS     R0,#+1
   \   00000210   0x4680             MOV      R8,R0
    456                  }
    457                  mmc = TRUE;
   \                     ??LPLD_SDHC_IOC_27: (+1)
   \   00000212   0x2001             MOVS     R0,#+1
   \   00000214   0xF88D 0x0001      STRB     R0,[SP, #+1]
    458                  
    459                  //CMD39 - 快速IO，检查CE-ATA的CE签名 */
    460                  command.COMMAND = ESDHC_CMD39;
   \   00000218   0x.... 0x....      LDR.W    R0,??DataTable11_3  ;; 0x27020000
   \   0000021C   0x9001             STR      R0,[SP, #+4]
    461                  command.ARGUMENT = 0x0C00;
   \   0000021E   0xF44F 0x6040      MOV      R0,#+3072
   \   00000222   0x9002             STR      R0,[SP, #+8]
    462                  command.BLOCKS = 0;
   \   00000224   0x2000             MOVS     R0,#+0
   \   00000226   0x9003             STR      R0,[SP, #+12]
    463                  if (result = LPLD_SDHC_SendCommand (&command))
   \   00000228   0xA801             ADD      R0,SP,#+4
   \   0000022A   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   0000022E   0x4681             MOV      R9,R0
   \   00000230   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000232   0x2800             CMP      R0,#+0
   \   00000234   0xF040 0x8206      BNE.W    ??LPLD_SDHC_IOC_9
    464                  {
    465                    break;
    466                  }
    467                  if (0xCE == (command.RESPONSE[0] >> 8) & 0xFF)
   \                     ??LPLD_SDHC_IOC_28: (+1)
   \   00000238   0x9805             LDR      R0,[SP, #+20]
   \   0000023A   0x0A00             LSRS     R0,R0,#+8
   \   0000023C   0x28CE             CMP      R0,#+206
   \   0000023E   0xD101             BNE.N    ??LPLD_SDHC_IOC_29
   \   00000240   0x2001             MOVS     R0,#+1
   \   00000242   0xE000             B.N      ??LPLD_SDHC_IOC_30
   \                     ??LPLD_SDHC_IOC_29: (+1)
   \   00000244   0x2000             MOVS     R0,#+0
   \                     ??LPLD_SDHC_IOC_30: (+1)
   \   00000246   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000248   0x2800             CMP      R0,#+0
   \   0000024A   0xF000 0x8083      BEQ.W    ??LPLD_SDHC_IOC_23
    468                  {
    469                    //CMD39 - 快速IO，检查CE-ATA的AA签名 */
    470                    command.COMMAND = ESDHC_CMD39;
   \   0000024E   0x.... 0x....      LDR.W    R0,??DataTable11_3  ;; 0x27020000
   \   00000252   0x9001             STR      R0,[SP, #+4]
    471                    command.ARGUMENT = 0x0D00;
   \   00000254   0xF44F 0x6050      MOV      R0,#+3328
   \   00000258   0x9002             STR      R0,[SP, #+8]
    472                    command.BLOCKS = 0;
   \   0000025A   0x2000             MOVS     R0,#+0
   \   0000025C   0x9003             STR      R0,[SP, #+12]
    473                    if (result = LPLD_SDHC_SendCommand (&command))
   \   0000025E   0xA801             ADD      R0,SP,#+4
   \   00000260   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   00000264   0x4681             MOV      R9,R0
   \   00000266   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000268   0x2800             CMP      R0,#+0
   \   0000026A   0xF040 0x81EB      BNE.W    ??LPLD_SDHC_IOC_9
    474                    {
    475                      break;
    476                    }
    477                    if (0xAA == (command.RESPONSE[0] >> 8) & 0xFF)
   \                     ??LPLD_SDHC_IOC_31: (+1)
   \   0000026E   0x9805             LDR      R0,[SP, #+20]
   \   00000270   0x0A00             LSRS     R0,R0,#+8
   \   00000272   0x28AA             CMP      R0,#+170
   \   00000274   0xD101             BNE.N    ??LPLD_SDHC_IOC_32
   \   00000276   0x2001             MOVS     R0,#+1
   \   00000278   0xE000             B.N      ??LPLD_SDHC_IOC_33
   \                     ??LPLD_SDHC_IOC_32: (+1)
   \   0000027A   0x2000             MOVS     R0,#+0
   \                     ??LPLD_SDHC_IOC_33: (+1)
   \   0000027C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000027E   0x2800             CMP      R0,#+0
   \   00000280   0xD068             BEQ.N    ??LPLD_SDHC_IOC_23
    478                    {
    479                      mmc = FALSE;
   \   00000282   0x2000             MOVS     R0,#+0
   \   00000284   0xF88D 0x0001      STRB     R0,[SP, #+1]
    480                      ceata = TRUE;
   \   00000288   0x2001             MOVS     R0,#+1
   \   0000028A   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   0000028E   0xE061             B.N      ??LPLD_SDHC_IOC_23
    481                    }
    482                  }
    483                }
    484                else
    485                {
    486                  //如果为SD卡
    487                  //ACMD41 - 发送操作状态
    488                  command.COMMAND = ESDHC_ACMD41;
   \                     ??LPLD_SDHC_IOC_25: (+1)
   \   00000290   0x.... 0x....      LDR.W    R0,??DataTable11_4  ;; 0x29020000
   \   00000294   0x9001             STR      R0,[SP, #+4]
    489                  command.ARGUMENT = 0;
   \   00000296   0x2000             MOVS     R0,#+0
   \   00000298   0x9002             STR      R0,[SP, #+8]
    490                  command.BLOCKS = 0;
   \   0000029A   0x2000             MOVS     R0,#+0
   \   0000029C   0x9003             STR      R0,[SP, #+12]
    491                  if (result = LPLD_SDHC_SendCommand (&command))
   \   0000029E   0xA801             ADD      R0,SP,#+4
   \   000002A0   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   000002A4   0x4681             MOV      R9,R0
   \   000002A6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002A8   0x2800             CMP      R0,#+0
   \   000002AA   0xD005             BEQ.N    ??LPLD_SDHC_IOC_34
    492                  {
    493                    sdcard_ptr->STATUS = SDHCSTA_NOINIT;
   \   000002AC   0x2001             MOVS     R0,#+1
   \   000002AE   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   000002B2   0x6809             LDR      R1,[R1, #+0]
   \   000002B4   0x6148             STR      R0,[R1, #+20]
    494                    break;
   \   000002B6   0xE1C5             B.N      ??LPLD_SDHC_IOC_9
    495                  }
    496                  if (command.RESPONSE[0] & 0x300000)
   \                     ??LPLD_SDHC_IOC_34: (+1)
   \   000002B8   0x9805             LDR      R0,[SP, #+20]
   \   000002BA   0xF410 0x1F40      TST      R0,#0x300000
   \   000002BE   0xD049             BEQ.N    ??LPLD_SDHC_IOC_23
    497                  {
    498                    val = 0;
   \   000002C0   0x2000             MOVS     R0,#+0
   \   000002C2   0x4683             MOV      R11,R0
    499                    do
    500                    {
    501                      val++;
   \                     ??LPLD_SDHC_IOC_35: (+1)
   \   000002C4   0xF11B 0x0B01      ADDS     R11,R11,#+1
    502                      
    503                      //CMD55 + ACMD41 - 发送OCR
    504                      command.COMMAND = ESDHC_CMD55;
   \   000002C8   0x.... 0x....      LDR.W    R0,??DataTable11_1  ;; 0x371a0000
   \   000002CC   0x9001             STR      R0,[SP, #+4]
    505                      command.ARGUMENT = 0;
   \   000002CE   0x2000             MOVS     R0,#+0
   \   000002D0   0x9002             STR      R0,[SP, #+8]
    506                      command.BLOCKS = 0;
   \   000002D2   0x2000             MOVS     R0,#+0
   \   000002D4   0x9003             STR      R0,[SP, #+12]
    507                      if (result = LPLD_SDHC_SendCommand (&command))
   \   000002D6   0xA801             ADD      R0,SP,#+4
   \   000002D8   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   000002DC   0x4681             MOV      R9,R0
   \   000002DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002E0   0x2800             CMP      R0,#+0
   \   000002E2   0xD11D             BNE.N    ??LPLD_SDHC_IOC_36
    508                      {
    509                        break;
    510                      }
    511                      
    512                      command.COMMAND = ESDHC_ACMD41;
   \                     ??LPLD_SDHC_IOC_37: (+1)
   \   000002E4   0x.... 0x....      LDR.W    R0,??DataTable11_4  ;; 0x29020000
   \   000002E8   0x9001             STR      R0,[SP, #+4]
    513                      if (hc)
   \   000002EA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000002EE   0xF1B8 0x0F00      CMP      R8,#+0
   \   000002F2   0xD003             BEQ.N    ??LPLD_SDHC_IOC_38
    514                      {
    515                        command.ARGUMENT = 0x40300000;
   \   000002F4   0x.... 0x....      LDR.W    R0,??DataTable11_2  ;; 0x40300000
   \   000002F8   0x9002             STR      R0,[SP, #+8]
   \   000002FA   0xE002             B.N      ??LPLD_SDHC_IOC_39
    516                      }
    517                      else
    518                      {
    519                        command.ARGUMENT = 0x00300000;
   \                     ??LPLD_SDHC_IOC_38: (+1)
   \   000002FC   0xF45F 0x1040      MOVS     R0,#+3145728
   \   00000300   0x9002             STR      R0,[SP, #+8]
    520                      }
    521                      command.BLOCKS = 0;
   \                     ??LPLD_SDHC_IOC_39: (+1)
   \   00000302   0x2000             MOVS     R0,#+0
   \   00000304   0x9003             STR      R0,[SP, #+12]
    522                      if (result = LPLD_SDHC_SendCommand (&command))
   \   00000306   0xA801             ADD      R0,SP,#+4
   \   00000308   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   0000030C   0x4681             MOV      R9,R0
   \   0000030E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000310   0x2800             CMP      R0,#+0
   \   00000312   0xD105             BNE.N    ??LPLD_SDHC_IOC_36
    523                      {
    524                        break;
    525                      }
    526                    } while ((0 == (command.RESPONSE[0] & 0x80000000)) && (val < ESDHC_ALARM_FREQUENCY));
   \                     ??LPLD_SDHC_IOC_40: (+1)
   \   00000314   0x9805             LDR      R0,[SP, #+20]
   \   00000316   0x2800             CMP      R0,#+0
   \   00000318   0xD402             BMI.N    ??LPLD_SDHC_IOC_36
   \   0000031A   0xF1BB 0x0F64      CMP      R11,#+100
   \   0000031E   0xDBD1             BLT.N    ??LPLD_SDHC_IOC_35
    527                    if (SDHCRES_OK != result)
   \                     ??LPLD_SDHC_IOC_36: (+1)
   \   00000320   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000324   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000328   0xF040 0x818C      BNE.W    ??LPLD_SDHC_IOC_9
    528                    {
    529                      break;
    530                    }
    531                    if (val >= ESDHC_ALARM_FREQUENCY)
   \                     ??LPLD_SDHC_IOC_41: (+1)
   \   0000032C   0xF1BB 0x0F64      CMP      R11,#+100
   \   00000330   0xDB02             BLT.N    ??LPLD_SDHC_IOC_42
    532                    {
    533                      hc = FALSE;
   \   00000332   0x2000             MOVS     R0,#+0
   \   00000334   0x4680             MOV      R8,R0
   \   00000336   0xE00D             B.N      ??LPLD_SDHC_IOC_23
    534                    }
    535                    else
    536                    {
    537                      mem = TRUE;
   \                     ??LPLD_SDHC_IOC_42: (+1)
   \   00000338   0x2001             MOVS     R0,#+1
   \   0000033A   0x0006             MOVS     R6,R0
    538                      if (hc)
   \   0000033C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000340   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000344   0xD006             BEQ.N    ??LPLD_SDHC_IOC_23
    539                      {
    540                        hc = FALSE;
   \   00000346   0x2000             MOVS     R0,#+0
   \   00000348   0x4680             MOV      R8,R0
    541                        if (command.RESPONSE[0] & 0x40000000)
   \   0000034A   0x9805             LDR      R0,[SP, #+20]
   \   0000034C   0x0040             LSLS     R0,R0,#+1
   \   0000034E   0xD501             BPL.N    ??LPLD_SDHC_IOC_23
    542                        {
    543                          hc = TRUE;
   \   00000350   0x2001             MOVS     R0,#+1
   \   00000352   0x4680             MOV      R8,R0
    544                        }
    545                      }
    546                    }
    547                  }
    548                }
    549              }
    550              if (mmc)
   \                     ??LPLD_SDHC_IOC_23: (+1)
   \   00000354   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000358   0x2800             CMP      R0,#+0
   \   0000035A   0xD004             BEQ.N    ??LPLD_SDHC_IOC_43
    551              {
    552                sdcard_ptr->CARD = ESDHC_CARD_MMC;
   \   0000035C   0x2007             MOVS     R0,#+7
   \   0000035E   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   00000362   0x6809             LDR      R1,[R1, #+0]
   \   00000364   0x6108             STR      R0,[R1, #+16]
    553              }
    554              if (ceata)
   \                     ??LPLD_SDHC_IOC_43: (+1)
   \   00000366   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000036A   0x2800             CMP      R0,#+0
   \   0000036C   0xD004             BEQ.N    ??LPLD_SDHC_IOC_44
    555              {
    556                sdcard_ptr->CARD = ESDHC_CARD_CEATA;
   \   0000036E   0x2008             MOVS     R0,#+8
   \   00000370   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   00000374   0x6809             LDR      R1,[R1, #+0]
   \   00000376   0x6108             STR      R0,[R1, #+16]
    557              }
    558              if (io)
   \                     ??LPLD_SDHC_IOC_44: (+1)
   \   00000378   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000037A   0x2F00             CMP      R7,#+0
   \   0000037C   0xD004             BEQ.N    ??LPLD_SDHC_IOC_45
    559              {
    560                sdcard_ptr->CARD = ESDHC_CARD_SDIO;
   \   0000037E   0x2004             MOVS     R0,#+4
   \   00000380   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   00000384   0x6809             LDR      R1,[R1, #+0]
   \   00000386   0x6108             STR      R0,[R1, #+16]
    561              }
    562              if (mem)
   \                     ??LPLD_SDHC_IOC_45: (+1)
   \   00000388   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000038A   0x2E00             CMP      R6,#+0
   \   0000038C   0xD00E             BEQ.N    ??LPLD_SDHC_IOC_46
    563              {
    564                sdcard_ptr->CARD = ESDHC_CARD_SD;
   \   0000038E   0x2002             MOVS     R0,#+2
   \   00000390   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   00000394   0x6809             LDR      R1,[R1, #+0]
   \   00000396   0x6108             STR      R0,[R1, #+16]
    565                if (hc)
   \   00000398   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000039C   0xF1B8 0x0F00      CMP      R8,#+0
   \   000003A0   0xD004             BEQ.N    ??LPLD_SDHC_IOC_46
    566                {
    567                  sdcard_ptr->CARD = ESDHC_CARD_SDHC;
   \   000003A2   0x2003             MOVS     R0,#+3
   \   000003A4   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   000003A8   0x6809             LDR      R1,[R1, #+0]
   \   000003AA   0x6108             STR      R0,[R1, #+16]
    568                }
    569              }
    570              if (io && mem)
   \                     ??LPLD_SDHC_IOC_46: (+1)
   \   000003AC   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000003AE   0x2F00             CMP      R7,#+0
   \   000003B0   0xD011             BEQ.N    ??LPLD_SDHC_IOC_47
   \   000003B2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000003B4   0x2E00             CMP      R6,#+0
   \   000003B6   0xD00E             BEQ.N    ??LPLD_SDHC_IOC_47
    571              {
    572                sdcard_ptr->CARD = ESDHC_CARD_SDCOMBO;
   \   000003B8   0x2005             MOVS     R0,#+5
   \   000003BA   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   000003BE   0x6809             LDR      R1,[R1, #+0]
   \   000003C0   0x6108             STR      R0,[R1, #+16]
    573                if (hc)
   \   000003C2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000003C6   0xF1B8 0x0F00      CMP      R8,#+0
   \   000003CA   0xD004             BEQ.N    ??LPLD_SDHC_IOC_47
    574                {
    575                  sdcard_ptr->CARD = ESDHC_CARD_SDHCCOMBO;
   \   000003CC   0x2006             MOVS     R0,#+6
   \   000003CE   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   000003D2   0x6809             LDR      R1,[R1, #+0]
   \   000003D4   0x6108             STR      R0,[R1, #+16]
    576                }
    577              }
    578              
    579              //禁用GPIO的SDHC复用
    580              LPLD_SDHC_InitGPIO (0);
   \                     ??LPLD_SDHC_IOC_47: (+1)
   \   000003D6   0x2000             MOVS     R0,#+0
   \   000003D8   0x.... 0x....      BL       LPLD_SDHC_InitGPIO
    581              
    582              //设置SDHC工作状态下的默认波特率
    583              LPLD_SDHC_SetBaudrate (g_core_clock*1000, 25000000);
   \   000003DC   0x.... 0x....      LDR.W    R1,??DataTable11_5  ;; 0x17d7840
   \   000003E0   0x.... 0x....      LDR.W    R0,??DataTable10_9
   \   000003E4   0x6800             LDR      R0,[R0, #+0]
   \   000003E6   0xF44F 0x727A      MOV      R2,#+1000
   \   000003EA   0x4350             MULS     R0,R2,R0
   \   000003EC   0x.... 0x....      BL       LPLD_SDHC_SetBaudrate
    584              
    585              //使能GPIO的SDHC复用
    586              LPLD_SDHC_InitGPIO (0xFFFF);
   \   000003F0   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000003F4   0x.... 0x....      BL       LPLD_SDHC_InitGPIO
    587              
    588              if(result == SDHCRES_OK)
   \   000003F8   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000003FC   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000400   0xD104             BNE.N    ??LPLD_SDHC_IOC_48
    589              {
    590                sdcard_ptr->STATUS = SDHCSTA_OK;
   \   00000402   0x2000             MOVS     R0,#+0
   \   00000404   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   00000408   0x6809             LDR      R1,[R1, #+0]
   \   0000040A   0x6148             STR      R0,[R1, #+20]
    591              }
    592              break;
   \                     ??LPLD_SDHC_IOC_48: (+1)
   \   0000040C   0xE11A             B.N      ??LPLD_SDHC_IOC_9
    593            case IO_IOCTL_ESDHC_SEND_COMMAND:
    594              result = LPLD_SDHC_SendCommand ((ESDHC_COMMAND_STRUCT_PTR)param32_ptr);
   \                     ??LPLD_SDHC_IOC_1: (+1)
   \   0000040E   0x4650             MOV      R0,R10
   \   00000410   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   00000414   0x4681             MOV      R9,R0
    595              break;
   \   00000416   0xE115             B.N      ??LPLD_SDHC_IOC_9
    596            case IO_IOCTL_ESDHC_GET_BAUDRATE:
    597              if (NULL == param32_ptr)
   \                     ??LPLD_SDHC_IOC_3: (+1)
   \   00000418   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000041C   0xD102             BNE.N    ??LPLD_SDHC_IOC_49
    598              {
    599                result = SDHCRES_ERROR;
   \   0000041E   0x2001             MOVS     R0,#+1
   \   00000420   0x4681             MOV      R9,R0
   \   00000422   0xE018             B.N      ??LPLD_SDHC_IOC_50
    600              }
    601              else
    602              {
    603                //获取波特率
    604                val = ((SDHC->SYSCTL & SDHC_SYSCTL_SDCLKFS_MASK) >> SDHC_SYSCTL_SDCLKFS_SHIFT) << 1;
   \                     ??LPLD_SDHC_IOC_49: (+1)
   \   00000424   0x.... 0x....      LDR.W    R0,??DataTable8_7  ;; 0x400b102c
   \   00000428   0x6800             LDR      R0,[R0, #+0]
   \   0000042A   0x09C0             LSRS     R0,R0,#+7
   \   0000042C   0xF410 0x70FF      ANDS     R0,R0,#0x1FE
   \   00000430   0x4683             MOV      R11,R0
    605                val *= ((SDHC->SYSCTL & SDHC_SYSCTL_DVS_MASK) >> SDHC_SYSCTL_DVS_SHIFT) + 1;
   \   00000432   0x.... 0x....      LDR.W    R0,??DataTable8_7  ;; 0x400b102c
   \   00000436   0x6800             LDR      R0,[R0, #+0]
   \   00000438   0xF3C0 0x1003      UBFX     R0,R0,#+4,#+4
   \   0000043C   0x1C40             ADDS     R0,R0,#+1
   \   0000043E   0xFB00 0xFB0B      MUL      R11,R0,R11
    606                *param32_ptr = (uint32)((g_core_clock*1000 / val));
   \   00000442   0x.... 0x....      LDR.W    R0,??DataTable10_9
   \   00000446   0x6800             LDR      R0,[R0, #+0]
   \   00000448   0xF44F 0x717A      MOV      R1,#+1000
   \   0000044C   0x4348             MULS     R0,R1,R0
   \   0000044E   0xFBB0 0xF0FB      UDIV     R0,R0,R11
   \   00000452   0xF8CA 0x0000      STR      R0,[R10, #+0]
    607              }
    608              break;
   \                     ??LPLD_SDHC_IOC_50: (+1)
   \   00000456   0xE0F5             B.N      ??LPLD_SDHC_IOC_9
    609            case IO_IOCTL_ESDHC_SET_BAUDRATE:
    610              if (NULL == param32_ptr)
   \                     ??LPLD_SDHC_IOC_4: (+1)
   \   00000458   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000045C   0xD102             BNE.N    ??LPLD_SDHC_IOC_51
    611              {
    612                result = SDHCRES_ERROR;
   \   0000045E   0x2001             MOVS     R0,#+1
   \   00000460   0x4681             MOV      R9,R0
   \   00000462   0xE01E             B.N      ??LPLD_SDHC_IOC_52
    613              }
    614              else if (0 == (*param32_ptr))
   \                     ??LPLD_SDHC_IOC_51: (+1)
   \   00000464   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000468   0x2800             CMP      R0,#+0
   \   0000046A   0xD102             BNE.N    ??LPLD_SDHC_IOC_53
    615              {
    616                result = SDHCRES_ERROR;
   \   0000046C   0x2001             MOVS     R0,#+1
   \   0000046E   0x4681             MOV      R9,R0
   \   00000470   0xE017             B.N      ??LPLD_SDHC_IOC_52
    617              }
    618              else
    619              {
    620                if (! LPLD_SDHC_IsRunning ())
   \                     ??LPLD_SDHC_IOC_53: (+1)
   \   00000472   0x.... 0x....      BL       LPLD_SDHC_IsRunning
   \   00000476   0x2800             CMP      R0,#+0
   \   00000478   0xD111             BNE.N    ??LPLD_SDHC_IOC_54
    621                {
    622                  //禁用GPIO的SDHC复用
    623                  LPLD_SDHC_InitGPIO (0);
   \   0000047A   0x2000             MOVS     R0,#+0
   \   0000047C   0x.... 0x....      BL       LPLD_SDHC_InitGPIO
    624                  
    625                  //设置波特率
    626                  LPLD_SDHC_SetBaudrate (g_core_clock*1000, *param32_ptr);
   \   00000480   0xF8DA 0x1000      LDR      R1,[R10, #+0]
   \   00000484   0x.... 0x....      LDR.W    R0,??DataTable10_9
   \   00000488   0x6800             LDR      R0,[R0, #+0]
   \   0000048A   0xF44F 0x727A      MOV      R2,#+1000
   \   0000048E   0x4350             MULS     R0,R2,R0
   \   00000490   0x.... 0x....      BL       LPLD_SDHC_SetBaudrate
    627                  
    628                  //使能GPIO的SDHC复用
    629                  LPLD_SDHC_InitGPIO (0xFFFF);
   \   00000494   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000498   0x.... 0x....      BL       LPLD_SDHC_InitGPIO
   \   0000049C   0xE001             B.N      ??LPLD_SDHC_IOC_52
    630                }
    631                else
    632                {
    633                  result = SDHCRES_ERROR;
   \                     ??LPLD_SDHC_IOC_54: (+1)
   \   0000049E   0x2001             MOVS     R0,#+1
   \   000004A0   0x4681             MOV      R9,R0
    634                }
    635              }
    636              break;
   \                     ??LPLD_SDHC_IOC_52: (+1)
   \   000004A2   0xE0CF             B.N      ??LPLD_SDHC_IOC_9
    637            case IO_IOCTL_ESDHC_GET_BUS_WIDTH:
    638              if (NULL == param32_ptr)
   \                     ??LPLD_SDHC_IOC_5: (+1)
   \   000004A4   0xF1BA 0x0F00      CMP      R10,#+0
   \   000004A8   0xD102             BNE.N    ??LPLD_SDHC_IOC_55
    639              {
    640                result = SDHCRES_ERROR;
   \   000004AA   0x2001             MOVS     R0,#+1
   \   000004AC   0x4681             MOV      R9,R0
   \   000004AE   0xE01C             B.N      ??LPLD_SDHC_IOC_56
    641              }
    642              else
    643              {
    644                //获得SDHC总线宽度
    645                val = (SDHC->PROCTL & SDHC_PROCTL_DTW_MASK) >> SDHC_PROCTL_DTW_SHIFT;
   \                     ??LPLD_SDHC_IOC_55: (+1)
   \   000004B0   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x400b1028
   \   000004B4   0x6800             LDR      R0,[R0, #+0]
   \   000004B6   0xF3C0 0x0041      UBFX     R0,R0,#+1,#+2
   \   000004BA   0x4683             MOV      R11,R0
    646                if (ESDHC_PROCTL_DTW_1BIT == val)
   \   000004BC   0xF1BB 0x0F00      CMP      R11,#+0
   \   000004C0   0xD103             BNE.N    ??LPLD_SDHC_IOC_57
    647                {
    648                  *param32_ptr = ESDHC_BUS_WIDTH_1BIT;
   \   000004C2   0x2000             MOVS     R0,#+0
   \   000004C4   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   000004C8   0xE00F             B.N      ??LPLD_SDHC_IOC_56
    649                }
    650                else if (ESDHC_PROCTL_DTW_4BIT == val)
   \                     ??LPLD_SDHC_IOC_57: (+1)
   \   000004CA   0xF1BB 0x0F01      CMP      R11,#+1
   \   000004CE   0xD103             BNE.N    ??LPLD_SDHC_IOC_58
    651                {
    652                  *param32_ptr = ESDHC_BUS_WIDTH_4BIT;
   \   000004D0   0x2001             MOVS     R0,#+1
   \   000004D2   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   000004D6   0xE008             B.N      ??LPLD_SDHC_IOC_56
    653                }
    654                else if (ESDHC_PROCTL_DTW_8BIT == val)
   \                     ??LPLD_SDHC_IOC_58: (+1)
   \   000004D8   0xF1BB 0x0F10      CMP      R11,#+16
   \   000004DC   0xD103             BNE.N    ??LPLD_SDHC_IOC_59
    655                {
    656                  *param32_ptr = ESDHC_BUS_WIDTH_8BIT;
   \   000004DE   0x2002             MOVS     R0,#+2
   \   000004E0   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   000004E4   0xE001             B.N      ??LPLD_SDHC_IOC_56
    657                }
    658                else
    659                {
    660                  result = SDHCRES_ERROR;
   \                     ??LPLD_SDHC_IOC_59: (+1)
   \   000004E6   0x2001             MOVS     R0,#+1
   \   000004E8   0x4681             MOV      R9,R0
    661                }
    662              }
    663              break;
   \                     ??LPLD_SDHC_IOC_56: (+1)
   \   000004EA   0xE0AB             B.N      ??LPLD_SDHC_IOC_9
    664            case IO_IOCTL_ESDHC_SET_BUS_WIDTH:
    665              if (NULL == param32_ptr)
   \                     ??LPLD_SDHC_IOC_6: (+1)
   \   000004EC   0xF1BA 0x0F00      CMP      R10,#+0
   \   000004F0   0xD102             BNE.N    ??LPLD_SDHC_IOC_60
    666              {
    667                result = SDHCRES_ERROR;
   \   000004F2   0x2001             MOVS     R0,#+1
   \   000004F4   0x4681             MOV      R9,R0
   \   000004F6   0xE043             B.N      ??LPLD_SDHC_IOC_61
    668              }
    669              else
    670              {
    671                //设置SDHC总线宽度
    672                if (! LPLD_SDHC_IsRunning ())
   \                     ??LPLD_SDHC_IOC_60: (+1)
   \   000004F8   0x.... 0x....      BL       LPLD_SDHC_IsRunning
   \   000004FC   0x2800             CMP      R0,#+0
   \   000004FE   0xD13D             BNE.N    ??LPLD_SDHC_IOC_62
    673                {
    674                  if (ESDHC_BUS_WIDTH_1BIT == *param32_ptr)
   \   00000500   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000504   0x2800             CMP      R0,#+0
   \   00000506   0xD10E             BNE.N    ??LPLD_SDHC_IOC_63
    675                  {
    676                    SDHC->PROCTL &= (~ SDHC_PROCTL_DTW_MASK);
   \   00000508   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x400b1028
   \   0000050C   0x6800             LDR      R0,[R0, #+0]
   \   0000050E   0xF030 0x0006      BICS     R0,R0,#0x6
   \   00000512   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x400b1028
   \   00000516   0x6008             STR      R0,[R1, #+0]
    677                    SDHC->PROCTL |= SDHC_PROCTL_DTW(ESDHC_PROCTL_DTW_1BIT);
   \   00000518   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x400b1028
   \   0000051C   0x6800             LDR      R0,[R0, #+0]
   \   0000051E   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x400b1028
   \   00000522   0x6008             STR      R0,[R1, #+0]
   \   00000524   0xE02C             B.N      ??LPLD_SDHC_IOC_61
    678                  }
    679                  else if (ESDHC_BUS_WIDTH_4BIT == *param32_ptr)
   \                     ??LPLD_SDHC_IOC_63: (+1)
   \   00000526   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   0000052A   0x2801             CMP      R0,#+1
   \   0000052C   0xD110             BNE.N    ??LPLD_SDHC_IOC_64
    680                  {
    681                    SDHC->PROCTL &= (~ SDHC_PROCTL_DTW_MASK);
   \   0000052E   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x400b1028
   \   00000532   0x6800             LDR      R0,[R0, #+0]
   \   00000534   0xF030 0x0006      BICS     R0,R0,#0x6
   \   00000538   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x400b1028
   \   0000053C   0x6008             STR      R0,[R1, #+0]
    682                    SDHC->PROCTL |= SDHC_PROCTL_DTW(ESDHC_PROCTL_DTW_4BIT);
   \   0000053E   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x400b1028
   \   00000542   0x6800             LDR      R0,[R0, #+0]
   \   00000544   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000548   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x400b1028
   \   0000054C   0x6008             STR      R0,[R1, #+0]
   \   0000054E   0xE017             B.N      ??LPLD_SDHC_IOC_61
    683                  }
    684                  else if (ESDHC_BUS_WIDTH_8BIT == *param32_ptr)
   \                     ??LPLD_SDHC_IOC_64: (+1)
   \   00000550   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000554   0x2802             CMP      R0,#+2
   \   00000556   0xD10E             BNE.N    ??LPLD_SDHC_IOC_65
    685                  {
    686                    SDHC->PROCTL &= (~ SDHC_PROCTL_DTW_MASK);
   \   00000558   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x400b1028
   \   0000055C   0x6800             LDR      R0,[R0, #+0]
   \   0000055E   0xF030 0x0006      BICS     R0,R0,#0x6
   \   00000562   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x400b1028
   \   00000566   0x6008             STR      R0,[R1, #+0]
    687                    SDHC->PROCTL |= SDHC_PROCTL_DTW(ESDHC_PROCTL_DTW_8BIT);
   \   00000568   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x400b1028
   \   0000056C   0x6800             LDR      R0,[R0, #+0]
   \   0000056E   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x400b1028
   \   00000572   0x6008             STR      R0,[R1, #+0]
   \   00000574   0xE004             B.N      ??LPLD_SDHC_IOC_61
    688                  }
    689                  else
    690                  {
    691                    result = SDHCRES_ERROR;
   \                     ??LPLD_SDHC_IOC_65: (+1)
   \   00000576   0x2001             MOVS     R0,#+1
   \   00000578   0x4681             MOV      R9,R0
   \   0000057A   0xE001             B.N      ??LPLD_SDHC_IOC_61
    692                  }
    693                }
    694                else
    695                {
    696                  result = SDHCRES_ERROR;
   \                     ??LPLD_SDHC_IOC_62: (+1)
   \   0000057C   0x2001             MOVS     R0,#+1
   \   0000057E   0x4681             MOV      R9,R0
    697                }
    698              }
    699              break;
   \                     ??LPLD_SDHC_IOC_61: (+1)
   \   00000580   0xE060             B.N      ??LPLD_SDHC_IOC_9
    700            case IO_IOCTL_ESDHC_GET_CARD:
    701              if (NULL == param32_ptr)
   \                     ??LPLD_SDHC_IOC_2: (+1)
   \   00000582   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000586   0xD102             BNE.N    ??LPLD_SDHC_IOC_66
    702              {
    703                result = SDHCRES_ERROR;
   \   00000588   0x2001             MOVS     R0,#+1
   \   0000058A   0x4681             MOV      R9,R0
   \   0000058C   0xE03B             B.N      ??LPLD_SDHC_IOC_67
    704              }
    705              else
    706              {
    707                //等待80个时钟
    708                SDHC->SYSCTL |= SDHC_SYSCTL_INITA_MASK;
   \                     ??LPLD_SDHC_IOC_66: (+1)
   \   0000058E   0x....             LDR.N    R0,??DataTable8_7  ;; 0x400b102c
   \   00000590   0x6800             LDR      R0,[R0, #+0]
   \   00000592   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   00000596   0x....             LDR.N    R1,??DataTable8_7  ;; 0x400b102c
   \   00000598   0x6008             STR      R0,[R1, #+0]
    709                while (SDHC->SYSCTL & SDHC_SYSCTL_INITA_MASK)
   \                     ??LPLD_SDHC_IOC_68: (+1)
   \   0000059A   0x....             LDR.N    R0,??DataTable8_7  ;; 0x400b102c
   \   0000059C   0x6800             LDR      R0,[R0, #+0]
   \   0000059E   0x0100             LSLS     R0,R0,#+4
   \   000005A0   0xD4FB             BMI.N    ??LPLD_SDHC_IOC_68
    710                { };
    711                
    712                //更新并返回卡实际状态
    713                if (SDHC->IRQSTAT & SDHC_IRQSTAT_CRM_MASK)
   \   000005A2   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   000005A6   0x6800             LDR      R0,[R0, #+0]
   \   000005A8   0x0600             LSLS     R0,R0,#+24
   \   000005AA   0xD511             BPL.N    ??LPLD_SDHC_IOC_69
    714                {
    715                  SDHC->IRQSTAT |= SDHC_IRQSTAT_CRM_MASK;
   \   000005AC   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   000005B0   0x6800             LDR      R0,[R0, #+0]
   \   000005B2   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000005B6   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x400b1030
   \   000005BA   0x6008             STR      R0,[R1, #+0]
    716                  sdcard_ptr->CARD = ESDHC_CARD_NONE;
   \   000005BC   0x2000             MOVS     R0,#+0
   \   000005BE   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   000005C2   0x6809             LDR      R1,[R1, #+0]
   \   000005C4   0x6108             STR      R0,[R1, #+16]
    717                  sdcard_ptr->STATUS = SDHCSTA_NODISK;
   \   000005C6   0x2002             MOVS     R0,#+2
   \   000005C8   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   000005CC   0x6809             LDR      R1,[R1, #+0]
   \   000005CE   0x6148             STR      R0,[R1, #+20]
    718                }
    719                if (SDHC->PRSSTAT & SDHC_PRSSTAT_CINS_MASK)
   \                     ??LPLD_SDHC_IOC_69: (+1)
   \   000005D0   0x....             LDR.N    R0,??DataTable8_8  ;; 0x400b1024
   \   000005D2   0x6800             LDR      R0,[R0, #+0]
   \   000005D4   0x03C0             LSLS     R0,R0,#+15
   \   000005D6   0xD50B             BPL.N    ??LPLD_SDHC_IOC_70
    720                {
    721                  if (ESDHC_CARD_NONE == sdcard_ptr->CARD)
   \   000005D8   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \   000005DC   0x6800             LDR      R0,[R0, #+0]
   \   000005DE   0x6900             LDR      R0,[R0, #+16]
   \   000005E0   0x2800             CMP      R0,#+0
   \   000005E2   0xD10A             BNE.N    ??LPLD_SDHC_IOC_71
    722                  {
    723                    sdcard_ptr->CARD = ESDHC_CARD_UNKNOWN;
   \   000005E4   0x2001             MOVS     R0,#+1
   \   000005E6   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   000005EA   0x6809             LDR      R1,[R1, #+0]
   \   000005EC   0x6108             STR      R0,[R1, #+16]
   \   000005EE   0xE004             B.N      ??LPLD_SDHC_IOC_71
    724                  }
    725                }
    726                else
    727                {
    728                  sdcard_ptr->CARD = ESDHC_CARD_NONE;
   \                     ??LPLD_SDHC_IOC_70: (+1)
   \   000005F0   0x2000             MOVS     R0,#+0
   \   000005F2   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   000005F6   0x6809             LDR      R1,[R1, #+0]
   \   000005F8   0x6108             STR      R0,[R1, #+16]
    729                }
    730                *param32_ptr = sdcard_ptr->CARD;
   \                     ??LPLD_SDHC_IOC_71: (+1)
   \   000005FA   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \   000005FE   0x6800             LDR      R0,[R0, #+0]
   \   00000600   0x6900             LDR      R0,[R0, #+16]
   \   00000602   0xF8CA 0x0000      STR      R0,[R10, #+0]
    731              }
    732              break;
   \                     ??LPLD_SDHC_IOC_67: (+1)
   \   00000606   0xE01D             B.N      ??LPLD_SDHC_IOC_9
    733              
    734            case IO_IOCTL_FLUSH_OUTPUT:
    735              //等待传输完成
    736              LPLD_SDHC_WaitStatus (SDHC_IRQSTAT_TC_MASK);
   \                     ??LPLD_SDHC_IOC_7: (+1)
   \   00000608   0x2002             MOVS     R0,#+2
   \   0000060A   0x.... 0x....      BL       LPLD_SDHC_WaitStatus
    737              if (SDHC->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \   0000060E   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   00000612   0x6800             LDR      R0,[R0, #+0]
   \   00000614   0xF410 0x0FE0      TST      R0,#0x700000
   \   00000618   0xD009             BEQ.N    ??LPLD_SDHC_IOC_72
    738              {
    739                SDHC->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK;
   \   0000061A   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   0000061E   0x6800             LDR      R0,[R0, #+0]
   \   00000620   0xF450 0x00E0      ORRS     R0,R0,#0x700000
   \   00000624   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x400b1030
   \   00000628   0x6008             STR      R0,[R1, #+0]
    740                result = SDHCRES_ERROR;
   \   0000062A   0x2001             MOVS     R0,#+1
   \   0000062C   0x4681             MOV      R9,R0
    741              }
    742              SDHC->IRQSTAT |= SDHC_IRQSTAT_TC_MASK | SDHC_IRQSTAT_BRR_MASK | SDHC_IRQSTAT_BWR_MASK;
   \                     ??LPLD_SDHC_IOC_72: (+1)
   \   0000062E   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   00000632   0x6800             LDR      R0,[R0, #+0]
   \   00000634   0xF050 0x0032      ORRS     R0,R0,#0x32
   \   00000638   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x400b1030
   \   0000063C   0x6008             STR      R0,[R1, #+0]
    743              break;
   \   0000063E   0xE001             B.N      ??LPLD_SDHC_IOC_9
    744            default:
    745              result = SDHCRES_ERROR;
   \                     ??LPLD_SDHC_IOC_8: (+1)
   \   00000640   0x2001             MOVS     R0,#+1
   \   00000642   0x4681             MOV      R9,R0
    746              break;
    747            }
    748            
    749            
    750            return result;
   \                     ??LPLD_SDHC_IOC_9: (+1)
   \   00000644   0x4648             MOV      R0,R9
   \   00000646   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000648   0xB009             ADD      SP,SP,#+36
   \   0000064A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    751          }
    752          
    753          /*
    754           * LPLD_SDHC_Read
    755           * SDHC读操作
    756           * 
    757           * 参数:
    758           *    *data_ptr--存储数据地址指针
    759           *    n--待读的数据长度
    760           *
    761           * 输出:
    762           *    SDHCRES--磁盘功能返回值
    763           */

   \                                 In section .text, align 2, keep-with-next
    764          static SDHCSTATUS LPLD_SDHC_Read(uint8 *data_ptr, int32 n)
    765          {
   \                     LPLD_SDHC_Read: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
    766            uint32 buffer;
    767            int32 remains;
    768            
    769            remains = n;
   \   00000004   0x000C             MOVS     R4,R1
    770            if (((uint32)data_ptr & 0x03) == 0)
   \   00000006   0xF012 0x0003      ANDS     R0,R2,#0x3
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD122             BNE.N    ??LPLD_SDHC_Read_0
    771            {    
    772              //数据位字对齐，可以以最快的速度直接从寄存器拷贝
    773              while (remains >= 4)
   \                     ??LPLD_SDHC_Read_1: (+1)
   \   0000000E   0x2C04             CMP      R4,#+4
   \   00000010   0xDB4D             BLT.N    ??LPLD_SDHC_Read_2
    774              {
    775                if (SDHC->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xF410 0x0FE0      TST      R0,#0x700000
   \   0000001C   0xD00B             BEQ.N    ??LPLD_SDHC_Read_3
    776                {
    777                  SDHC->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BRR_MASK;
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   00000028   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000002C   0x.... 0x....      LDR.W    R5,??DataTable9  ;; 0x400b1030
   \   00000030   0x6028             STR      R0,[R5, #+0]
    778                  return SDHCRES_ERROR;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE075             B.N      ??LPLD_SDHC_Read_4
    779                }
    780                
    781                //等待，直到收到的数据达到水印长度或传输完成
    782                while ((0 == (SDHC->PRSSTAT & SDHC_PRSSTAT_BREN_MASK)) && (SDHC->PRSSTAT & SDHC_PRSSTAT_DLA_MASK))
   \                     ??LPLD_SDHC_Read_3: (+1)
   \   00000036   0x....             LDR.N    R0,??DataTable8_8  ;; 0x400b1024
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x0500             LSLS     R0,R0,#+20
   \   0000003C   0xD403             BMI.N    ??LPLD_SDHC_Read_5
   \   0000003E   0x....             LDR.N    R0,??DataTable8_8  ;; 0x400b1024
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x0740             LSLS     R0,R0,#+29
   \   00000044   0xD4F7             BMI.N    ??LPLD_SDHC_Read_3
    783                { };
    784                
    785                *((uint32 *)data_ptr) = SDHC->DATPORT;
   \                     ??LPLD_SDHC_Read_5: (+1)
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable11_6  ;; 0x400b1020
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x6010             STR      R0,[R2, #+0]
    786                data_ptr += 4;
   \   0000004E   0x1D12             ADDS     R2,R2,#+4
    787                remains -= 4;
   \   00000050   0x1F24             SUBS     R4,R4,#+4
   \   00000052   0xE7DC             B.N      ??LPLD_SDHC_Read_1
    788              }
    789            }
    790            else
    791            {
    792              //非对齐数据，读到临时区域并以字节复制
    793              while (remains >= 4)
   \                     ??LPLD_SDHC_Read_0: (+1)
   \   00000054   0x2C04             CMP      R4,#+4
   \   00000056   0xDB2A             BLT.N    ??LPLD_SDHC_Read_2
    794              {
    795                if (SDHC->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xF410 0x0FE0      TST      R0,#0x700000
   \   00000062   0xD00B             BEQ.N    ??LPLD_SDHC_Read_6
    796                {
    797                  SDHC->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BRR_MASK;
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   0000006E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000072   0x.... 0x....      LDR.W    R5,??DataTable9  ;; 0x400b1030
   \   00000076   0x6028             STR      R0,[R5, #+0]
    798                  return SDHCRES_ERROR;
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0xE052             B.N      ??LPLD_SDHC_Read_4
    799                }
    800                
    801                //等待，直到收到的数据达到水印长度或传输完成
    802                while ((0 == (SDHC->PRSSTAT & SDHC_PRSSTAT_BREN_MASK)) && (SDHC->PRSSTAT & SDHC_PRSSTAT_DLA_MASK))
   \                     ??LPLD_SDHC_Read_6: (+1)
   \   0000007C   0x....             LDR.N    R0,??DataTable8_8  ;; 0x400b1024
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x0500             LSLS     R0,R0,#+20
   \   00000082   0xD403             BMI.N    ??LPLD_SDHC_Read_7
   \   00000084   0x....             LDR.N    R0,??DataTable8_8  ;; 0x400b1024
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x0740             LSLS     R0,R0,#+29
   \   0000008A   0xD4F7             BMI.N    ??LPLD_SDHC_Read_6
    803                { };
    804                
    805                buffer = SDHC->DATPORT;
   \                     ??LPLD_SDHC_Read_7: (+1)
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable11_6  ;; 0x400b1020
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x0003             MOVS     R3,R0
    806                
    807                *data_ptr++ = buffer & 0xFF;
   \   00000094   0x7013             STRB     R3,[R2, #+0]
   \   00000096   0x1C52             ADDS     R2,R2,#+1
    808                *data_ptr++ = (buffer >> 8) & 0xFF;
   \   00000098   0x0A18             LSRS     R0,R3,#+8
   \   0000009A   0x7010             STRB     R0,[R2, #+0]
   \   0000009C   0x1C52             ADDS     R2,R2,#+1
    809                *data_ptr++ = (buffer >> 16) & 0xFF;
   \   0000009E   0x0C18             LSRS     R0,R3,#+16
   \   000000A0   0x7010             STRB     R0,[R2, #+0]
   \   000000A2   0x1C52             ADDS     R2,R2,#+1
    810                *data_ptr++ = (buffer >> 24) & 0xFF;
   \   000000A4   0x0E18             LSRS     R0,R3,#+24
   \   000000A6   0x7010             STRB     R0,[R2, #+0]
   \   000000A8   0x1C52             ADDS     R2,R2,#+1
    811                
    812                remains -= 4;
   \   000000AA   0x1F24             SUBS     R4,R4,#+4
   \   000000AC   0xE7D2             B.N      ??LPLD_SDHC_Read_0
    813              }      
    814            }
    815            
    816            if (remains)
   \                     ??LPLD_SDHC_Read_2: (+1)
   \   000000AE   0x2C00             CMP      R4,#+0
   \   000000B0   0xD024             BEQ.N    ??LPLD_SDHC_Read_8
    817            {
    818              //剩下的少于单字长度数据
    819              if (SDHC->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0xF410 0x0FE0      TST      R0,#0x700000
   \   000000BC   0xD00B             BEQ.N    ??LPLD_SDHC_Read_9
    820              {
    821                SDHC->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BRR_MASK;
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   000000C2   0x6800             LDR      R0,[R0, #+0]
   \   000000C4   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   000000C8   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000CC   0x.... 0x....      LDR.W    R5,??DataTable9  ;; 0x400b1030
   \   000000D0   0x6028             STR      R0,[R5, #+0]
    822                return SDHCRES_ERROR;
   \   000000D2   0x2001             MOVS     R0,#+1
   \   000000D4   0xE025             B.N      ??LPLD_SDHC_Read_4
    823              }
    824              
    825              //等待，直到收到的数据达到水印长度或传输完成
    826              while ((0 == (SDHC->PRSSTAT & SDHC_PRSSTAT_BREN_MASK)) && (SDHC->PRSSTAT & SDHC_PRSSTAT_DLA_MASK))
   \                     ??LPLD_SDHC_Read_9: (+1)
   \   000000D6   0x....             LDR.N    R0,??DataTable8_8  ;; 0x400b1024
   \   000000D8   0x6800             LDR      R0,[R0, #+0]
   \   000000DA   0x0500             LSLS     R0,R0,#+20
   \   000000DC   0xD403             BMI.N    ??LPLD_SDHC_Read_10
   \   000000DE   0x....             LDR.N    R0,??DataTable8_8  ;; 0x400b1024
   \   000000E0   0x6800             LDR      R0,[R0, #+0]
   \   000000E2   0x0740             LSLS     R0,R0,#+29
   \   000000E4   0xD4F7             BMI.N    ??LPLD_SDHC_Read_9
    827              { };
    828              
    829              buffer = SDHC->DATPORT;
   \                     ??LPLD_SDHC_Read_10: (+1)
   \   000000E6   0x.... 0x....      LDR.W    R0,??DataTable11_6  ;; 0x400b1020
   \   000000EA   0x6800             LDR      R0,[R0, #+0]
   \   000000EC   0x0003             MOVS     R3,R0
    830              while (remains)
   \                     ??LPLD_SDHC_Read_11: (+1)
   \   000000EE   0x2C00             CMP      R4,#+0
   \   000000F0   0xD004             BEQ.N    ??LPLD_SDHC_Read_8
    831              {
    832                
    833                *data_ptr++ = buffer & 0xFF;
   \   000000F2   0x7013             STRB     R3,[R2, #+0]
   \   000000F4   0x1C52             ADDS     R2,R2,#+1
    834                buffer >>= 8;
   \   000000F6   0x0A1B             LSRS     R3,R3,#+8
    835                
    836                remains--;
   \   000000F8   0x1E64             SUBS     R4,R4,#+1
   \   000000FA   0xE7F8             B.N      ??LPLD_SDHC_Read_11
    837              }
    838            }
    839            
    840            if (SDHC->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \                     ??LPLD_SDHC_Read_8: (+1)
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   00000100   0x6800             LDR      R0,[R0, #+0]
   \   00000102   0xF410 0x0FE0      TST      R0,#0x700000
   \   00000106   0xD00B             BEQ.N    ??LPLD_SDHC_Read_12
    841            {
    842              SDHC->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BRR_MASK;
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   0000010C   0x6800             LDR      R0,[R0, #+0]
   \   0000010E   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   00000112   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000116   0x.... 0x....      LDR.W    R5,??DataTable9  ;; 0x400b1030
   \   0000011A   0x6028             STR      R0,[R5, #+0]
    843              return SDHCRES_ERROR;
   \   0000011C   0x2001             MOVS     R0,#+1
   \   0000011E   0xE000             B.N      ??LPLD_SDHC_Read_4
    844            }
    845            
    846            return (n - remains);
   \                     ??LPLD_SDHC_Read_12: (+1)
   \   00000120   0x1B08             SUBS     R0,R1,R4
   \                     ??LPLD_SDHC_Read_4: (+1)
   \   00000122   0xBC30             POP      {R4,R5}
   \   00000124   0x4770             BX       LR               ;; return
    847          }
    848          
    849          /*
    850           * LPLD_SDHC_Write
    851           * SDHC写操作
    852           * 
    853           * 参数:
    854           *    *data_ptr--存储数据地址指针
    855           *    n--待写的数据长度
    856           *
    857           * 输出:
    858           *    SDHCRES--磁盘功能返回值
    859           */

   \                                 In section .text, align 2, keep-with-next
    860          static SDHCSTATUS LPLD_SDHC_Write(uint8 *data_ptr, int32 n)
    861          {
   \                     LPLD_SDHC_Write: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0002             MOVS     R2,R0
    862            uint8 *udata_ptr;
    863            uint32 buffer;
    864            int32 remains;
    865            
    866            //复制数据指针
    867            udata_ptr = (uint8 *)data_ptr;
   \   00000004   0x0013             MOVS     R3,R2
    868            
    869            remains = n;
   \   00000006   0x000D             MOVS     R5,R1
    870            if (((uint32)udata_ptr & 0x03) == 0)
   \   00000008   0xF013 0x0003      ANDS     R0,R3,#0x3
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD11E             BNE.N    ??LPLD_SDHC_Write_0
    871            {
    872              //数据位字对齐，可以以最快的速度直接拷贝到寄存器
    873              while (remains >= 4)
   \                     ??LPLD_SDHC_Write_1: (+1)
   \   00000010   0x2D04             CMP      R5,#+4
   \   00000012   0xDB4A             BLT.N    ??LPLD_SDHC_Write_2
    874              {
    875                if (SDHC->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF410 0x0FE0      TST      R0,#0x700000
   \   0000001E   0xD00B             BEQ.N    ??LPLD_SDHC_Write_3
    876                {
    877                  SDHC->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BWR_MASK;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   0000002A   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000002E   0x.... 0x....      LDR.W    R6,??DataTable9  ;; 0x400b1030
   \   00000032   0x6030             STR      R0,[R6, #+0]
    878                  return SDHCRES_ERROR;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xE06A             B.N      ??LPLD_SDHC_Write_4
    879                }
    880                
    881                //等待，直到水印空间可用 
    882                while (0 == (SDHC->PRSSTAT & SDHC_PRSSTAT_BWEN_MASK))
   \                     ??LPLD_SDHC_Write_3: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable8_8  ;; 0x400b1024
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x0540             LSLS     R0,R0,#+21
   \   0000003E   0xD5FB             BPL.N    ??LPLD_SDHC_Write_3
    883                { };
    884                
    885                SDHC->DATPORT = *((uint32 *)udata_ptr);
   \   00000040   0x6818             LDR      R0,[R3, #+0]
   \   00000042   0x.... 0x....      LDR.W    R6,??DataTable11_6  ;; 0x400b1020
   \   00000046   0x6030             STR      R0,[R6, #+0]
    886                udata_ptr += 4;
   \   00000048   0x1D1B             ADDS     R3,R3,#+4
    887                remains -= 4;
   \   0000004A   0x1F2D             SUBS     R5,R5,#+4
   \   0000004C   0xE7E0             B.N      ??LPLD_SDHC_Write_1
    888              }
    889            }
    890            else
    891            {
    892              //非对齐数据，写到临时区域并以字节复制
    893              while (remains >= 4)
   \                     ??LPLD_SDHC_Write_0: (+1)
   \   0000004E   0x2D04             CMP      R5,#+4
   \   00000050   0xDB2B             BLT.N    ??LPLD_SDHC_Write_2
    894              {
    895                if (SDHC->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x400b1030
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0xF410 0x0FE0      TST      R0,#0x700000
   \   0000005C   0xD009             BEQ.N    ??LPLD_SDHC_Write_5
    896                {
    897                  SDHC->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BWR_MASK;
   \   0000005E   0x....             LDR.N    R0,??DataTable9  ;; 0x400b1030
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   00000066   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000006A   0x....             LDR.N    R6,??DataTable9  ;; 0x400b1030
   \   0000006C   0x6030             STR      R0,[R6, #+0]
    898                  return SDHCRES_ERROR;
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0xE04D             B.N      ??LPLD_SDHC_Write_4
    899                }
    900                
    901                //等待，直到水印空间可用 
    902                while (0 == (SDHC->PRSSTAT & SDHC_PRSSTAT_BWEN_MASK))
   \                     ??LPLD_SDHC_Write_5: (+1)
   \   00000072   0x....             LDR.N    R0,??DataTable8_8  ;; 0x400b1024
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x0540             LSLS     R0,R0,#+21
   \   00000078   0xD5FB             BPL.N    ??LPLD_SDHC_Write_5
    903                { };
    904                
    905                buffer  = (*udata_ptr++);
   \   0000007A   0x7818             LDRB     R0,[R3, #+0]
   \   0000007C   0x0004             MOVS     R4,R0
   \   0000007E   0x1C5B             ADDS     R3,R3,#+1
    906                buffer |= (*udata_ptr++) << 8;
   \   00000080   0x7818             LDRB     R0,[R3, #+0]
   \   00000082   0xEA54 0x2400      ORRS     R4,R4,R0, LSL #+8
   \   00000086   0x1C5B             ADDS     R3,R3,#+1
    907                buffer |= (*udata_ptr++) << 16;
   \   00000088   0x7818             LDRB     R0,[R3, #+0]
   \   0000008A   0xEA54 0x4400      ORRS     R4,R4,R0, LSL #+16
   \   0000008E   0x1C5B             ADDS     R3,R3,#+1
    908                buffer |= (*udata_ptr++) << 24;
   \   00000090   0x7818             LDRB     R0,[R3, #+0]
   \   00000092   0xEA54 0x6400      ORRS     R4,R4,R0, LSL #+24
   \   00000096   0x1C5B             ADDS     R3,R3,#+1
    909                
    910                //等待，直到水印空间可用 
    911                while (0 == (SDHC->PRSSTAT & SDHC_PRSSTAT_BWEN_MASK))
   \                     ??LPLD_SDHC_Write_6: (+1)
   \   00000098   0x....             LDR.N    R0,??DataTable8_8  ;; 0x400b1024
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0x0540             LSLS     R0,R0,#+21
   \   0000009E   0xD5FB             BPL.N    ??LPLD_SDHC_Write_6
    912                { };
    913                
    914                SDHC->DATPORT = buffer;
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable11_6  ;; 0x400b1020
   \   000000A4   0x6004             STR      R4,[R0, #+0]
    915                remains -= 4;
   \   000000A6   0x1F2D             SUBS     R5,R5,#+4
   \   000000A8   0xE7D1             B.N      ??LPLD_SDHC_Write_0
    916              }      
    917            }
    918            
    919            if (remains)
   \                     ??LPLD_SDHC_Write_2: (+1)
   \   000000AA   0x2D00             CMP      R5,#+0
   \   000000AC   0xD01F             BEQ.N    ??LPLD_SDHC_Write_7
    920            {
    921              //剩余少于单字长度的数据
    922              if (SDHC->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \   000000AE   0x....             LDR.N    R0,??DataTable9  ;; 0x400b1030
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0xF410 0x0FE0      TST      R0,#0x700000
   \   000000B6   0xD009             BEQ.N    ??LPLD_SDHC_Write_8
    923              {
    924                SDHC->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BWR_MASK;
   \   000000B8   0x....             LDR.N    R0,??DataTable9  ;; 0x400b1030
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   000000C0   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   000000C4   0x....             LDR.N    R6,??DataTable9  ;; 0x400b1030
   \   000000C6   0x6030             STR      R0,[R6, #+0]
    925                return SDHCRES_ERROR;
   \   000000C8   0x2001             MOVS     R0,#+1
   \   000000CA   0xE020             B.N      ??LPLD_SDHC_Write_4
    926              }
    927              
    928              buffer = 0xFFFFFFFF;
   \                     ??LPLD_SDHC_Write_8: (+1)
   \   000000CC   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000D0   0x0004             MOVS     R4,R0
    929              while (remains)
   \                     ??LPLD_SDHC_Write_9: (+1)
   \   000000D2   0x2D00             CMP      R5,#+0
   \   000000D4   0xD004             BEQ.N    ??LPLD_SDHC_Write_10
    930              {
    931                buffer <<= 8;
   \   000000D6   0x0224             LSLS     R4,R4,#+8
    932                buffer |= udata_ptr[remains];
   \   000000D8   0x5CE8             LDRB     R0,[R5, R3]
   \   000000DA   0x4304             ORRS     R4,R0,R4
    933                remains--;
   \   000000DC   0x1E6D             SUBS     R5,R5,#+1
   \   000000DE   0xE7F8             B.N      ??LPLD_SDHC_Write_9
    934              }
    935              
    936              //等待，直到水印空间可用 
    937              while (0 == (SDHC->PRSSTAT & SDHC_PRSSTAT_BWEN_MASK))
   \                     ??LPLD_SDHC_Write_10: (+1)
   \   000000E0   0x....             LDR.N    R0,??DataTable8_8  ;; 0x400b1024
   \   000000E2   0x6800             LDR      R0,[R0, #+0]
   \   000000E4   0x0540             LSLS     R0,R0,#+21
   \   000000E6   0xD5FB             BPL.N    ??LPLD_SDHC_Write_10
    938              { };
    939              
    940              SDHC->DATPORT = buffer;        
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable11_6  ;; 0x400b1020
   \   000000EC   0x6004             STR      R4,[R0, #+0]
    941            }
    942            
    943            if (SDHC->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \                     ??LPLD_SDHC_Write_7: (+1)
   \   000000EE   0x....             LDR.N    R0,??DataTable9  ;; 0x400b1030
   \   000000F0   0x6800             LDR      R0,[R0, #+0]
   \   000000F2   0xF410 0x0FE0      TST      R0,#0x700000
   \   000000F6   0xD009             BEQ.N    ??LPLD_SDHC_Write_11
    944            {
    945              SDHC->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BWR_MASK;
   \   000000F8   0x....             LDR.N    R0,??DataTable9  ;; 0x400b1030
   \   000000FA   0x6800             LDR      R0,[R0, #+0]
   \   000000FC   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   00000100   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000104   0x....             LDR.N    R6,??DataTable9  ;; 0x400b1030
   \   00000106   0x6030             STR      R0,[R6, #+0]
    946              return SDHCRES_ERROR;
   \   00000108   0x2001             MOVS     R0,#+1
   \   0000010A   0xE000             B.N      ??LPLD_SDHC_Write_4
    947            }
    948            
    949            return (n - remains);
   \                     ??LPLD_SDHC_Write_11: (+1)
   \   0000010C   0x1B48             SUBS     R0,R1,R5
   \                     ??LPLD_SDHC_Write_4: (+1)
   \   0000010E   0xBC70             POP      {R4-R6}
   \   00000110   0x4770             BX       LR               ;; return
    950          }
    951          
    952          /*
    953           * LPLD_SDHC_InitCard
    954           * 初始化SDHC模块及SD卡，设置正常工作波特率为40MHz
    955           * 
    956           * 参数:
    957           *    无
    958           *
    959           * 输出:
    960           *    SDHCSTA_OK--状态正常
    961           *    SDHCSTA_NOINIT--驱动未初始化
    962           *    SDHCSTA_NODISK--为插入卡
    963           *    SDHCSTA_PROTECT--卡写保护
    964           */

   \                                 In section .text, align 2, keep-with-next
    965          SDHCSTATUS LPLD_SDHC_InitCard(void)
    966          {
   \                     LPLD_SDHC_InitCard: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB08A             SUB      SP,SP,#+40
    967            uint32 param, c_size, c_size_mult, read_bl_len, time_out = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    968            ESDHC_COMMAND_STRUCT command;
    969            SDHCSTATUS result;
    970            
    971            //分配SD卡信息结构体的数据空间并初始化
    972            sdcard_ptr = (SDCARD_STRUCT_PTR)malloc(sizeof(SDCARD_STRUCT));
   \   00000008   0x2018             MOVS     R0,#+24
   \   0000000A   0x.... 0x....      BL       malloc
   \   0000000E   0x....             LDR.N    R1,??DataTable9_1
   \   00000010   0x6008             STR      R0,[R1, #+0]
    973            sdcard_ptr->CARD = ESDHC_CARD_NONE;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x....             LDR.N    R1,??DataTable9_1
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0x6108             STR      R0,[R1, #+16]
    974            sdcard_ptr->TIMEOUT = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x....             LDR.N    R1,??DataTable9_1
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x6008             STR      R0,[R1, #+0]
    975            sdcard_ptr->NUM_BLOCKS = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR.N    R1,??DataTable9_1
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x6048             STR      R0,[R1, #+4]
    976            sdcard_ptr->ADDRESS = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x....             LDR.N    R1,??DataTable9_1
   \   0000002E   0x6809             LDR      R1,[R1, #+0]
   \   00000030   0x60C8             STR      R0,[R1, #+12]
    977            sdcard_ptr->HC = FALSE;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x....             LDR.N    R1,??DataTable9_1
   \   00000036   0x6809             LDR      R1,[R1, #+0]
   \   00000038   0x7208             STRB     R0,[R1, #+8]
    978            sdcard_ptr->VERSION2 = FALSE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x....             LDR.N    R1,??DataTable9_1
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0x7248             STRB     R0,[R1, #+9]
    979            sdcard_ptr->STATUS = SDHCSTA_OK;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x....             LDR.N    R1,??DataTable9_1
   \   00000046   0x6809             LDR      R1,[R1, #+0]
   \   00000048   0x6148             STR      R0,[R1, #+20]
    980             
    981            while(time_out < 1000)
   \                     ??LPLD_SDHC_InitCard_0: (+1)
   \   0000004A   0xF5B6 0x7F7A      CMP      R6,#+1000
   \   0000004E   0xD22E             BCS.N    ??LPLD_SDHC_InitCard_1
    982            {
    983              
    984              //初始化SDHC模块并检测卡
    985              if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_INIT, NULL)))
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000058   0x4680             MOV      R8,R0
   \   0000005A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000005E   0xD1F4             BNE.N    ??LPLD_SDHC_InitCard_0
    986              {
    987                continue;
    988              }
    989              
    990              //SDHC检查
    991              param = 0;
   \                     ??LPLD_SDHC_InitCard_2: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x9000             STR      R0,[SP, #+0]
    992              if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_GET_CARD, &param)))
   \   00000064   0xA900             ADD      R1,SP,#+0
   \   00000066   0x2003             MOVS     R0,#+3
   \   00000068   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   0000006C   0x4680             MOV      R8,R0
   \   0000006E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000072   0xD1EA             BNE.N    ??LPLD_SDHC_InitCard_0
    993              {
    994                continue;
    995              }
    996              if ((ESDHC_CARD_SD == param) || (ESDHC_CARD_SDHC == param) || (ESDHC_CARD_SDCOMBO == param) || (ESDHC_CARD_SDHCCOMBO == param))
   \                     ??LPLD_SDHC_InitCard_3: (+1)
   \   00000074   0x9800             LDR      R0,[SP, #+0]
   \   00000076   0x2802             CMP      R0,#+2
   \   00000078   0xD008             BEQ.N    ??LPLD_SDHC_InitCard_4
   \   0000007A   0x9800             LDR      R0,[SP, #+0]
   \   0000007C   0x2803             CMP      R0,#+3
   \   0000007E   0xD005             BEQ.N    ??LPLD_SDHC_InitCard_4
   \   00000080   0x9800             LDR      R0,[SP, #+0]
   \   00000082   0x2805             CMP      R0,#+5
   \   00000084   0xD002             BEQ.N    ??LPLD_SDHC_InitCard_4
   \   00000086   0x9800             LDR      R0,[SP, #+0]
   \   00000088   0x2806             CMP      R0,#+6
   \   0000008A   0xD10F             BNE.N    ??LPLD_SDHC_InitCard_5
    997              {
    998                if ((ESDHC_CARD_SDHC == param) || (ESDHC_CARD_SDHCCOMBO == param))
   \                     ??LPLD_SDHC_InitCard_4: (+1)
   \   0000008C   0x9800             LDR      R0,[SP, #+0]
   \   0000008E   0x2803             CMP      R0,#+3
   \   00000090   0xD002             BEQ.N    ??LPLD_SDHC_InitCard_6
   \   00000092   0x9800             LDR      R0,[SP, #+0]
   \   00000094   0x2806             CMP      R0,#+6
   \   00000096   0xD104             BNE.N    ??LPLD_SDHC_InitCard_7
    999                {
   1000                  sdcard_ptr->HC = TRUE;
   \                     ??LPLD_SDHC_InitCard_6: (+1)
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0x....             LDR.N    R1,??DataTable9_1
   \   0000009C   0x6809             LDR      R1,[R1, #+0]
   \   0000009E   0x7208             STRB     R0,[R1, #+8]
   1001                  break;
   \   000000A0   0xE005             B.N      ??LPLD_SDHC_InitCard_1
   1002                }
   1003                else if(ESDHC_CARD_SD == param)
   \                     ??LPLD_SDHC_InitCard_7: (+1)
   \   000000A2   0x9800             LDR      R0,[SP, #+0]
   \   000000A4   0x2802             CMP      R0,#+2
   \   000000A6   0xD002             BEQ.N    ??LPLD_SDHC_InitCard_1
   1004                {
   1005                  break;
   1006                }
   1007              }
   1008              else
   1009              {
   1010                continue;
   1011              }
   1012              time_out++;
   \                     ??LPLD_SDHC_InitCard_8: (+1)
   \   000000A8   0x1C76             ADDS     R6,R6,#+1
   \   000000AA   0xE7CE             B.N      ??LPLD_SDHC_InitCard_0
   \                     ??LPLD_SDHC_InitCard_5: (+1)
   \   000000AC   0xE7CD             B.N      ??LPLD_SDHC_InitCard_0
   1013            }
   1014            
   1015            if(time_out >= 1000)
   \                     ??LPLD_SDHC_InitCard_1: (+1)
   \   000000AE   0xF5B6 0x7F7A      CMP      R6,#+1000
   \   000000B2   0xD301             BCC.N    ??LPLD_SDHC_InitCard_9
   1016              return SDHCRES_NOTRDY;
   \   000000B4   0x2003             MOVS     R0,#+3
   \   000000B6   0xE0C8             B.N      ??LPLD_SDHC_InitCard_10
   1017            
   1018            //卡识别
   1019            command.COMMAND = ESDHC_CMD2;
   \                     ??LPLD_SDHC_InitCard_9: (+1)
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable11_7  ;; 0x2090000
   \   000000BC   0x9001             STR      R0,[SP, #+4]
   1020            command.ARGUMENT = 0;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x9002             STR      R0,[SP, #+8]
   1021            command.BLOCKS = 0;
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0x9003             STR      R0,[SP, #+12]
   1022            if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   000000C6   0xA901             ADD      R1,SP,#+4
   \   000000C8   0x2002             MOVS     R0,#+2
   \   000000CA   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   000000CE   0x4680             MOV      R8,R0
   \   000000D0   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000D4   0xD001             BEQ.N    ??LPLD_SDHC_InitCard_11
   1023            {
   1024              return result;
   \   000000D6   0x4640             MOV      R0,R8
   \   000000D8   0xE0B7             B.N      ??LPLD_SDHC_InitCard_10
   1025            }
   1026            
   1027            //获取卡地址
   1028            command.COMMAND = ESDHC_CMD3;
   \                     ??LPLD_SDHC_InitCard_11: (+1)
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable11_8  ;; 0x31a0000
   \   000000DE   0x9001             STR      R0,[SP, #+4]
   1029            command.ARGUMENT = 0;
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x9002             STR      R0,[SP, #+8]
   1030            command.BLOCKS = 0;
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0x9003             STR      R0,[SP, #+12]
   1031            if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   000000E8   0xA901             ADD      R1,SP,#+4
   \   000000EA   0x2002             MOVS     R0,#+2
   \   000000EC   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   000000F0   0x4680             MOV      R8,R0
   \   000000F2   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000F6   0xD001             BEQ.N    ??LPLD_SDHC_InitCard_12
   1032            {
   1033              return result;
   \   000000F8   0x4640             MOV      R0,R8
   \   000000FA   0xE0A6             B.N      ??LPLD_SDHC_InitCard_10
   1034            }
   1035            sdcard_ptr->ADDRESS = command.RESPONSE[0] & 0xFFFF0000;
   \                     ??LPLD_SDHC_InitCard_12: (+1)
   \   000000FC   0x9805             LDR      R0,[SP, #+20]
   \   000000FE   0x0C00             LSRS     R0,R0,#+16
   \   00000100   0x0400             LSLS     R0,R0,#+16
   \   00000102   0x....             LDR.N    R1,??DataTable9_1
   \   00000104   0x6809             LDR      R1,[R1, #+0]
   \   00000106   0x60C8             STR      R0,[R1, #+12]
   1036            
   1037            //获取卡参数
   1038            command.COMMAND = ESDHC_CMD9;
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable11_9  ;; 0x9090000
   \   0000010C   0x9001             STR      R0,[SP, #+4]
   1039            command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   0000010E   0x....             LDR.N    R0,??DataTable9_1
   \   00000110   0x6800             LDR      R0,[R0, #+0]
   \   00000112   0x68C0             LDR      R0,[R0, #+12]
   \   00000114   0x9002             STR      R0,[SP, #+8]
   1040            command.BLOCKS = 0;
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0x9003             STR      R0,[SP, #+12]
   1041            if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   0000011A   0xA901             ADD      R1,SP,#+4
   \   0000011C   0x2002             MOVS     R0,#+2
   \   0000011E   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000122   0x4680             MOV      R8,R0
   \   00000124   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000128   0xD001             BEQ.N    ??LPLD_SDHC_InitCard_13
   1042            {
   1043              return result;
   \   0000012A   0x4640             MOV      R0,R8
   \   0000012C   0xE08D             B.N      ??LPLD_SDHC_InitCard_10
   1044            }
   1045            if (0 == (command.RESPONSE[3] & 0x00C00000))
   \                     ??LPLD_SDHC_InitCard_13: (+1)
   \   0000012E   0x9808             LDR      R0,[SP, #+32]
   \   00000130   0xF410 0x0F40      TST      R0,#0xC00000
   \   00000134   0xD11E             BNE.N    ??LPLD_SDHC_InitCard_14
   1046            {
   1047              read_bl_len = (command.RESPONSE[2] >> 8) & 0x0F;
   \   00000136   0x9807             LDR      R0,[SP, #+28]
   \   00000138   0xF3C0 0x2003      UBFX     R0,R0,#+8,#+4
   \   0000013C   0x0005             MOVS     R5,R0
   1048              c_size = command.RESPONSE[2] & 0x03;
   \   0000013E   0xF89D 0x001C      LDRB     R0,[SP, #+28]
   \   00000142   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000146   0x0007             MOVS     R7,R0
   1049              c_size = (c_size << 10) | (command.RESPONSE[1] >> 22);
   \   00000148   0x9806             LDR      R0,[SP, #+24]
   \   0000014A   0x0D80             LSRS     R0,R0,#+22
   \   0000014C   0xEA50 0x2787      ORRS     R7,R0,R7, LSL #+10
   1050              c_size_mult = (command.RESPONSE[1] >> 7) & 0x07;
   \   00000150   0x9806             LDR      R0,[SP, #+24]
   \   00000152   0xF3C0 0x10C2      UBFX     R0,R0,#+7,#+3
   \   00000156   0x0004             MOVS     R4,R0
   1051              sdcard_ptr->NUM_BLOCKS = (c_size + 1) * (1 << (c_size_mult + 2)) * (1 << (read_bl_len - 9));
   \   00000158   0x1C78             ADDS     R0,R7,#+1
   \   0000015A   0x2101             MOVS     R1,#+1
   \   0000015C   0x1CA2             ADDS     R2,R4,#+2
   \   0000015E   0x4091             LSLS     R1,R1,R2
   \   00000160   0x4348             MULS     R0,R1,R0
   \   00000162   0x2101             MOVS     R1,#+1
   \   00000164   0x002A             MOVS     R2,R5
   \   00000166   0x3A09             SUBS     R2,R2,#+9
   \   00000168   0x4091             LSLS     R1,R1,R2
   \   0000016A   0x4348             MULS     R0,R1,R0
   \   0000016C   0x....             LDR.N    R1,??DataTable9_1
   \   0000016E   0x6809             LDR      R1,[R1, #+0]
   \   00000170   0x6048             STR      R0,[R1, #+4]
   \   00000172   0xE00C             B.N      ??LPLD_SDHC_InitCard_15
   1052            }
   1053            else
   1054            {
   1055              sdcard_ptr->VERSION2 = TRUE;
   \                     ??LPLD_SDHC_InitCard_14: (+1)
   \   00000174   0x2001             MOVS     R0,#+1
   \   00000176   0x....             LDR.N    R1,??DataTable9_1
   \   00000178   0x6809             LDR      R1,[R1, #+0]
   \   0000017A   0x7248             STRB     R0,[R1, #+9]
   1056              c_size = (command.RESPONSE[1] >> 8) & 0x003FFFFF;
   \   0000017C   0x9806             LDR      R0,[SP, #+24]
   \   0000017E   0xF3C0 0x2015      UBFX     R0,R0,#+8,#+22
   \   00000182   0x0007             MOVS     R7,R0
   1057              sdcard_ptr->NUM_BLOCKS = (c_size + 1) << 10;
   \   00000184   0x1C78             ADDS     R0,R7,#+1
   \   00000186   0x0280             LSLS     R0,R0,#+10
   \   00000188   0x....             LDR.N    R1,??DataTable9_1
   \   0000018A   0x6809             LDR      R1,[R1, #+0]
   \   0000018C   0x6048             STR      R0,[R1, #+4]
   1058            }
   1059            
   1060            //设置正常工作波特率为40MHz
   1061            //param = 40000000;    
   1062            param = 25000000;      
   \                     ??LPLD_SDHC_InitCard_15: (+1)
   \   0000018E   0x....             LDR.N    R0,??DataTable11_5  ;; 0x17d7840
   \   00000190   0x9000             STR      R0,[SP, #+0]
   1063            if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SET_BAUDRATE, &param)))
   \   00000192   0xA900             ADD      R1,SP,#+0
   \   00000194   0x2005             MOVS     R0,#+5
   \   00000196   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   0000019A   0x4680             MOV      R8,R0
   \   0000019C   0xF1B8 0x0F00      CMP      R8,#+0
   \   000001A0   0xD001             BEQ.N    ??LPLD_SDHC_InitCard_16
   1064            {
   1065              return result;
   \   000001A2   0x4640             MOV      R0,R8
   \   000001A4   0xE051             B.N      ??LPLD_SDHC_InitCard_10
   1066            }
   1067            
   1068            //选择卡
   1069            command.COMMAND = ESDHC_CMD7;
   \                     ??LPLD_SDHC_InitCard_16: (+1)
   \   000001A6   0x....             LDR.N    R0,??DataTable11_10  ;; 0x71b0000
   \   000001A8   0x9001             STR      R0,[SP, #+4]
   1070            command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   000001AA   0x....             LDR.N    R0,??DataTable9_1
   \   000001AC   0x6800             LDR      R0,[R0, #+0]
   \   000001AE   0x68C0             LDR      R0,[R0, #+12]
   \   000001B0   0x9002             STR      R0,[SP, #+8]
   1071            command.BLOCKS = 0;
   \   000001B2   0x2000             MOVS     R0,#+0
   \   000001B4   0x9003             STR      R0,[SP, #+12]
   1072            if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   000001B6   0xA901             ADD      R1,SP,#+4
   \   000001B8   0x2002             MOVS     R0,#+2
   \   000001BA   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   000001BE   0x4680             MOV      R8,R0
   \   000001C0   0xF1B8 0x0F00      CMP      R8,#+0
   \   000001C4   0xD001             BEQ.N    ??LPLD_SDHC_InitCard_17
   1073            {
   1074              return result;
   \   000001C6   0x4640             MOV      R0,R8
   \   000001C8   0xE03F             B.N      ??LPLD_SDHC_InitCard_10
   1075            }
   1076            
   1077            //设置块大小为512字节
   1078            command.COMMAND = ESDHC_CMD16;
   \                     ??LPLD_SDHC_InitCard_17: (+1)
   \   000001CA   0x....             LDR.N    R0,??DataTable11_11  ;; 0x101a0000
   \   000001CC   0x9001             STR      R0,[SP, #+4]
   1079            command.ARGUMENT = IO_SDCARD_BLOCK_SIZE;
   \   000001CE   0xF44F 0x7000      MOV      R0,#+512
   \   000001D2   0x9002             STR      R0,[SP, #+8]
   1080            command.BLOCKS = 0;
   \   000001D4   0x2000             MOVS     R0,#+0
   \   000001D6   0x9003             STR      R0,[SP, #+12]
   1081            if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   000001D8   0xA901             ADD      R1,SP,#+4
   \   000001DA   0x2002             MOVS     R0,#+2
   \   000001DC   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   000001E0   0x4680             MOV      R8,R0
   \   000001E2   0xF1B8 0x0F00      CMP      R8,#+0
   \   000001E6   0xD001             BEQ.N    ??LPLD_SDHC_InitCard_18
   1082            {
   1083              return result;
   \   000001E8   0x4640             MOV      R0,R8
   \   000001EA   0xE02E             B.N      ??LPLD_SDHC_InitCard_10
   1084            }
   1085            
   1086            if (ESDHC_BUS_WIDTH_4BIT == ESDHC_BUS_WIDTH_4BIT)
   1087            {
   1088              //特殊应用命令
   1089              command.COMMAND = ESDHC_CMD55;
   \                     ??LPLD_SDHC_InitCard_18: (+1)
   \   000001EC   0x....             LDR.N    R0,??DataTable11_1  ;; 0x371a0000
   \   000001EE   0x9001             STR      R0,[SP, #+4]
   1090              command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   000001F0   0x....             LDR.N    R0,??DataTable9_1
   \   000001F2   0x6800             LDR      R0,[R0, #+0]
   \   000001F4   0x68C0             LDR      R0,[R0, #+12]
   \   000001F6   0x9002             STR      R0,[SP, #+8]
   1091              command.BLOCKS = 0;
   \   000001F8   0x2000             MOVS     R0,#+0
   \   000001FA   0x9003             STR      R0,[SP, #+12]
   1092              if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   000001FC   0xA901             ADD      R1,SP,#+4
   \   000001FE   0x2002             MOVS     R0,#+2
   \   00000200   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000204   0x4680             MOV      R8,R0
   \   00000206   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000020A   0xD001             BEQ.N    ??LPLD_SDHC_InitCard_19
   1093              {
   1094                return result;
   \   0000020C   0x4640             MOV      R0,R8
   \   0000020E   0xE01C             B.N      ??LPLD_SDHC_InitCard_10
   1095              }
   1096              
   1097              //设置总线宽度为4bit
   1098              command.COMMAND = ESDHC_ACMD6;
   \                     ??LPLD_SDHC_InitCard_19: (+1)
   \   00000210   0x....             LDR.N    R0,??DataTable11_12  ;; 0x61a0000
   \   00000212   0x9001             STR      R0,[SP, #+4]
   1099              command.ARGUMENT = 2;
   \   00000214   0x2002             MOVS     R0,#+2
   \   00000216   0x9002             STR      R0,[SP, #+8]
   1100              command.BLOCKS = 0;
   \   00000218   0x2000             MOVS     R0,#+0
   \   0000021A   0x9003             STR      R0,[SP, #+12]
   1101              if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   0000021C   0xA901             ADD      R1,SP,#+4
   \   0000021E   0x2002             MOVS     R0,#+2
   \   00000220   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000224   0x4680             MOV      R8,R0
   \   00000226   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000022A   0xD001             BEQ.N    ??LPLD_SDHC_InitCard_20
   1102              {
   1103                return result;
   \   0000022C   0x4640             MOV      R0,R8
   \   0000022E   0xE00C             B.N      ??LPLD_SDHC_InitCard_10
   1104              }
   1105              
   1106              param = ESDHC_BUS_WIDTH_4BIT;
   \                     ??LPLD_SDHC_InitCard_20: (+1)
   \   00000230   0x2001             MOVS     R0,#+1
   \   00000232   0x9000             STR      R0,[SP, #+0]
   1107              if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SET_BUS_WIDTH, &param)))
   \   00000234   0xA900             ADD      R1,SP,#+0
   \   00000236   0x2007             MOVS     R0,#+7
   \   00000238   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   0000023C   0x4680             MOV      R8,R0
   \   0000023E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000242   0xD001             BEQ.N    ??LPLD_SDHC_InitCard_21
   1108              {
   1109                return result;
   \   00000244   0x4640             MOV      R0,R8
   \   00000246   0xE000             B.N      ??LPLD_SDHC_InitCard_10
   1110              }
   1111            }
   1112            
   1113            return SDHCRES_OK;
   \                     ??LPLD_SDHC_InitCard_21: (+1)
   \   00000248   0x2000             MOVS     R0,#+0
   \                     ??LPLD_SDHC_InitCard_10: (+1)
   \   0000024A   0xB00A             ADD      SP,SP,#+40
   \   0000024C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1114          }
   1115          
   1116          
   1117          /*
   1118           * LPLD_SDHC_ReadBlocks
   1119           * 读指定扇区指定长度的块
   1120           * 
   1121           * 参数:
   1122           *    buff--存储读出数据的地址指针
   1123           *    sector--开始的扇区号
   1124           *    count--读出的扇区数（块数）
   1125           *
   1126           * 输出:
   1127           *    SDHCRES--磁盘功能返回值
   1128           */

   \                                 In section .text, align 2, keep-with-next
   1129          SDHCRES LPLD_SDHC_ReadBlocks(uint8 *buff, uint32 sector, uint32 count)
   1130          {
   \                     LPLD_SDHC_ReadBlocks: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x4688             MOV      R8,R1
   \   0000000A   0x0015             MOVS     R5,R2
   1131            ESDHC_COMMAND_STRUCT command;
   1132            int cnt;
   1133            int32 result;
   1134            
   1135            //SD卡数据地址调节
   1136            if (! sdcard_ptr->HC)
   \   0000000C   0x....             LDR.N    R0,??DataTable11_13
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x7A00             LDRB     R0,[R0, #+8]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD101             BNE.N    ??LPLD_SDHC_ReadBlocks_0
   1137            {
   1138              sector <<= IO_SDCARD_BLOCK_SIZE_POWER;
   \   00000016   0xEA5F 0x2848      LSLS     R8,R8,#+9
   1139            }
   1140            
   1141            //设置读块命令
   1142            if (count > 1)
   \                     ??LPLD_SDHC_ReadBlocks_0: (+1)
   \   0000001A   0x2D02             CMP      R5,#+2
   \   0000001C   0xD302             BCC.N    ??LPLD_SDHC_ReadBlocks_1
   1143            {
   1144              command.COMMAND = ESDHC_CMD18;
   \   0000001E   0x....             LDR.N    R0,??DataTable11_14  ;; 0x121a0034
   \   00000020   0x9000             STR      R0,[SP, #+0]
   \   00000022   0xE001             B.N      ??LPLD_SDHC_ReadBlocks_2
   1145            }   
   1146            else
   1147            {
   1148              command.COMMAND = ESDHC_CMD17;
   \                     ??LPLD_SDHC_ReadBlocks_1: (+1)
   \   00000024   0x....             LDR.N    R0,??DataTable11_15  ;; 0x111a0010
   \   00000026   0x9000             STR      R0,[SP, #+0]
   1149            }
   1150            
   1151            command.ARGUMENT = sector;
   \                     ??LPLD_SDHC_ReadBlocks_2: (+1)
   \   00000028   0xF8CD 0x8004      STR      R8,[SP, #+4]
   1152            command.BLOCKS = count;
   \   0000002C   0x9502             STR      R5,[SP, #+8]
   1153            command.BLOCKSIZE = IO_SDCARD_BLOCK_SIZE;
   \   0000002E   0xF44F 0x7000      MOV      R0,#+512
   \   00000032   0x9003             STR      R0,[SP, #+12]
   1154            if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   00000034   0xA900             ADD      R1,SP,#+0
   \   00000036   0x2002             MOVS     R0,#+2
   \   00000038   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   0000003C   0x0007             MOVS     R7,R0
   \   0000003E   0x2F00             CMP      R7,#+0
   \   00000040   0xD002             BEQ.N    ??LPLD_SDHC_ReadBlocks_3
   1155            {
   1156              return (SDHCRES)result;
   \   00000042   0x0038             MOVS     R0,R7
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0xE01F             B.N      ??LPLD_SDHC_ReadBlocks_4
   1157            }
   1158            
   1159            //读取数据
   1160            for (cnt = 0; cnt < count; cnt++)
   \                     ??LPLD_SDHC_ReadBlocks_3: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x0006             MOVS     R6,R0
   \                     ??LPLD_SDHC_ReadBlocks_5: (+1)
   \   0000004C   0x42AE             CMP      R6,R5
   \   0000004E   0xD20F             BCS.N    ??LPLD_SDHC_ReadBlocks_6
   1161            {
   1162              if (IO_SDCARD_BLOCK_SIZE != (result=LPLD_SDHC_Read(buff,IO_SDCARD_BLOCK_SIZE)))
   \   00000050   0xF44F 0x7100      MOV      R1,#+512
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       LPLD_SDHC_Read
   \   0000005A   0x0007             MOVS     R7,R0
   \   0000005C   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000060   0xD002             BEQ.N    ??LPLD_SDHC_ReadBlocks_7
   1163              {
   1164                return (SDHCRES)result;
   \   00000062   0x0038             MOVS     R0,R7
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0xE00F             B.N      ??LPLD_SDHC_ReadBlocks_4
   1165              }
   1166              buff += IO_SDCARD_BLOCK_SIZE;
   \                     ??LPLD_SDHC_ReadBlocks_7: (+1)
   \   00000068   0xF514 0x7400      ADDS     R4,R4,#+512
   1167            }
   \   0000006C   0x1C76             ADDS     R6,R6,#+1
   \   0000006E   0xE7ED             B.N      ??LPLD_SDHC_ReadBlocks_5
   1168            
   1169            //等待传输结束
   1170            if (SDHCRES_OK !=(result=LPLD_SDHC_IOC (IO_IOCTL_FLUSH_OUTPUT, NULL)))
   \                     ??LPLD_SDHC_ReadBlocks_6: (+1)
   \   00000070   0x2100             MOVS     R1,#+0
   \   00000072   0x2093             MOVS     R0,#+147
   \   00000074   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000078   0x0007             MOVS     R7,R0
   \   0000007A   0x2F00             CMP      R7,#+0
   \   0000007C   0xD002             BEQ.N    ??LPLD_SDHC_ReadBlocks_8
   1171            {
   1172              return (SDHCRES)result;
   \   0000007E   0x0038             MOVS     R0,R7
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0xE001             B.N      ??LPLD_SDHC_ReadBlocks_4
   1173            }
   1174            
   1175            return (SDHCRES)result;
   \                     ??LPLD_SDHC_ReadBlocks_8: (+1)
   \   00000084   0x0038             MOVS     R0,R7
   \   00000086   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??LPLD_SDHC_ReadBlocks_4: (+1)
   \   00000088   0xB008             ADD      SP,SP,#+32
   \   0000008A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1176          }
   1177          
   1178          
   1179          /*
   1180           * LPLD_SDHC_WriteBlocks
   1181           * 在指定扇区写入指定长度块数数据
   1182           * 
   1183           * 参数:
   1184           *    buff--存储待写入数据的地址指针
   1185           *    sector--开始的扇区号
   1186           *    count--写入的扇区数（块数）
   1187           *
   1188           * 输出:
   1189           *    SDHCRES--磁盘功能返回值
   1190           */

   \                                 In section .text, align 2, keep-with-next
   1191          SDHCRES LPLD_SDHC_WriteBlocks(uint8* buff, uint32 sector, uint32 count)
   1192          {
   \                     LPLD_SDHC_WriteBlocks: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB08A             SUB      SP,SP,#+40
   \   00000006   0x0006             MOVS     R6,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0014             MOVS     R4,R2
   1193              ESDHC_COMMAND_STRUCT command;
   1194              uint8               tmp[4];
   1195              int32             cnt;
   1196                int32 result;
   1197              
   1198           
   1199              //SD卡数据地址调节
   1200              if (! sdcard_ptr->HC)
   \   0000000C   0x....             LDR.N    R0,??DataTable11_13
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x7A00             LDRB     R0,[R0, #+8]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD100             BNE.N    ??LPLD_SDHC_WriteBlocks_0
   1201              {
   1202                  sector <<= IO_SDCARD_BLOCK_SIZE_POWER;
   \   00000016   0x026D             LSLS     R5,R5,#+9
   1203              }
   1204          
   1205              //设置写块命令
   1206              if (count > 1)
   \                     ??LPLD_SDHC_WriteBlocks_0: (+1)
   \   00000018   0x2C02             CMP      R4,#+2
   \   0000001A   0xD302             BCC.N    ??LPLD_SDHC_WriteBlocks_1
   1207              {
   1208                  command.COMMAND = ESDHC_CMD25;
   \   0000001C   0x....             LDR.N    R0,??DataTable11_16  ;; 0x191a0024
   \   0000001E   0x9001             STR      R0,[SP, #+4]
   \   00000020   0xE001             B.N      ??LPLD_SDHC_WriteBlocks_2
   1209              }
   1210              else
   1211              {
   1212                  command.COMMAND = ESDHC_CMD24;
   \                     ??LPLD_SDHC_WriteBlocks_1: (+1)
   \   00000022   0x....             LDR.N    R0,??DataTable11_17  ;; 0x181a0000
   \   00000024   0x9001             STR      R0,[SP, #+4]
   1213              }
   1214          
   1215              command.ARGUMENT = sector;
   \                     ??LPLD_SDHC_WriteBlocks_2: (+1)
   \   00000026   0x9502             STR      R5,[SP, #+8]
   1216              command.BLOCKS = count;
   \   00000028   0x9403             STR      R4,[SP, #+12]
   1217              command.BLOCKSIZE = IO_SDCARD_BLOCK_SIZE;
   \   0000002A   0xF44F 0x7000      MOV      R0,#+512
   \   0000002E   0x9004             STR      R0,[SP, #+16]
   1218              if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   00000030   0xA901             ADD      R1,SP,#+4
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000038   0x4680             MOV      R8,R0
   \   0000003A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000003E   0xD002             BEQ.N    ??LPLD_SDHC_WriteBlocks_3
   1219              {
   1220                  return (SDHCRES)result;
   \   00000040   0x4640             MOV      R0,R8
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0xE091             B.N      ??LPLD_SDHC_WriteBlocks_4
   1221              }
   1222              
   1223              //写数据
   1224              for (cnt = 0; cnt < count; cnt++)
   \                     ??LPLD_SDHC_WriteBlocks_3: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x0007             MOVS     R7,R0
   \                     ??LPLD_SDHC_WriteBlocks_5: (+1)
   \   0000004A   0x42A7             CMP      R7,R4
   \   0000004C   0xD20F             BCS.N    ??LPLD_SDHC_WriteBlocks_6
   1225              {
   1226                  if (IO_SDCARD_BLOCK_SIZE != (result=LPLD_SDHC_Write (buff, IO_SDCARD_BLOCK_SIZE)))
   \   0000004E   0xF44F 0x7100      MOV      R1,#+512
   \   00000052   0x0030             MOVS     R0,R6
   \   00000054   0x.... 0x....      BL       LPLD_SDHC_Write
   \   00000058   0x4680             MOV      R8,R0
   \   0000005A   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000005E   0xD002             BEQ.N    ??LPLD_SDHC_WriteBlocks_7
   1227                  {
   1228                      return (SDHCRES)result;
   \   00000060   0x4640             MOV      R0,R8
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0xE081             B.N      ??LPLD_SDHC_WriteBlocks_4
   1229                  }
   1230                  buff += IO_SDCARD_BLOCK_SIZE;
   \                     ??LPLD_SDHC_WriteBlocks_7: (+1)
   \   00000066   0xF516 0x7600      ADDS     R6,R6,#+512
   1231              }
   \   0000006A   0x1C7F             ADDS     R7,R7,#+1
   \   0000006C   0xE7ED             B.N      ??LPLD_SDHC_WriteBlocks_5
   1232          
   1233              //等待传输结束
   1234              if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_FLUSH_OUTPUT, NULL)))
   \                     ??LPLD_SDHC_WriteBlocks_6: (+1)
   \   0000006E   0x2100             MOVS     R1,#+0
   \   00000070   0x2093             MOVS     R0,#+147
   \   00000072   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000076   0x4680             MOV      R8,R0
   \   00000078   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000007C   0xD002             BEQ.N    ??LPLD_SDHC_WriteBlocks_8
   1235              {
   1236                  return (SDHCRES)result;
   \   0000007E   0x4640             MOV      R0,R8
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0xE072             B.N      ??LPLD_SDHC_WriteBlocks_4
   1237              }
   1238          
   1239              //等待卡准备好/传输状态
   1240              do
   1241              {
   1242                  command.COMMAND = ESDHC_CMD13;
   \                     ??LPLD_SDHC_WriteBlocks_8: (+1)
   \   00000084   0x....             LDR.N    R0,??DataTable11_18  ;; 0xd1a0000
   \   00000086   0x9001             STR      R0,[SP, #+4]
   1243                  command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   00000088   0x....             LDR.N    R0,??DataTable11_13
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x68C0             LDR      R0,[R0, #+12]
   \   0000008E   0x9002             STR      R0,[SP, #+8]
   1244                  command.BLOCKS = 0;
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x9003             STR      R0,[SP, #+12]
   1245                  if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   00000094   0xA901             ADD      R1,SP,#+4
   \   00000096   0x2002             MOVS     R0,#+2
   \   00000098   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   0000009C   0x4680             MOV      R8,R0
   \   0000009E   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000A2   0xD002             BEQ.N    ??LPLD_SDHC_WriteBlocks_9
   1246                  {
   1247                      return (SDHCRES)result;
   \   000000A4   0x4640             MOV      R0,R8
   \   000000A6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A8   0xE05F             B.N      ??LPLD_SDHC_WriteBlocks_4
   1248                  }
   1249          
   1250                  //卡状态错误检查
   1251                  if (command.RESPONSE[0] & 0xFFD98008)
   \                     ??LPLD_SDHC_WriteBlocks_9: (+1)
   \   000000AA   0x9805             LDR      R0,[SP, #+20]
   \   000000AC   0x....             LDR.N    R1,??DataTable11_19  ;; 0xffd98008
   \   000000AE   0x4208             TST      R0,R1
   \   000000B0   0xD002             BEQ.N    ??LPLD_SDHC_WriteBlocks_10
   1252                  {
   1253                      count = 0; /* necessary to get real number of written blocks */
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x0004             MOVS     R4,R0
   1254                      break;
   \   000000B6   0xE005             B.N      ??LPLD_SDHC_WriteBlocks_11
   1255                  }
   1256          
   1257              } while (0x000000900 != (command.RESPONSE[0] & 0x00001F00));
   \                     ??LPLD_SDHC_WriteBlocks_10: (+1)
   \   000000B8   0x9805             LDR      R0,[SP, #+20]
   \   000000BA   0xF410 0x50F8      ANDS     R0,R0,#0x1F00
   \   000000BE   0xF5B0 0x6F10      CMP      R0,#+2304
   \   000000C2   0xD1DF             BNE.N    ??LPLD_SDHC_WriteBlocks_8
   1258          
   1259              if (cnt != count)
   \                     ??LPLD_SDHC_WriteBlocks_11: (+1)
   \   000000C4   0x42A7             CMP      R7,R4
   \   000000C6   0xD04F             BEQ.N    ??LPLD_SDHC_WriteBlocks_12
   1260              {
   1261                  //特殊应用命令
   1262                  command.COMMAND = ESDHC_CMD55;
   \   000000C8   0x....             LDR.N    R0,??DataTable11_1  ;; 0x371a0000
   \   000000CA   0x9001             STR      R0,[SP, #+4]
   1263                  command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   000000CC   0x....             LDR.N    R0,??DataTable11_13
   \   000000CE   0x6800             LDR      R0,[R0, #+0]
   \   000000D0   0x68C0             LDR      R0,[R0, #+12]
   \   000000D2   0x9002             STR      R0,[SP, #+8]
   1264                  command.BLOCKS = 0;
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0x9003             STR      R0,[SP, #+12]
   1265                  if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   000000D8   0xA901             ADD      R1,SP,#+4
   \   000000DA   0x2002             MOVS     R0,#+2
   \   000000DC   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   000000E0   0x4680             MOV      R8,R0
   \   000000E2   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000E6   0xD002             BEQ.N    ??LPLD_SDHC_WriteBlocks_13
   1266                  {
   1267                      return (SDHCRES)result;
   \   000000E8   0x4640             MOV      R0,R8
   \   000000EA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EC   0xE03D             B.N      ??LPLD_SDHC_WriteBlocks_4
   1268                  }
   1269                          
   1270                  //使用ACMD22命令获得写入的块数量
   1271                  command.COMMAND = ESDHC_ACMD22;
   \                     ??LPLD_SDHC_WriteBlocks_13: (+1)
   \   000000EE   0x....             LDR.N    R0,??DataTable11_20  ;; 0x161a0010
   \   000000F0   0x9001             STR      R0,[SP, #+4]
   1272                  command.ARGUMENT = 0;
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0x9002             STR      R0,[SP, #+8]
   1273                  command.BLOCKS = 1;
   \   000000F6   0x2001             MOVS     R0,#+1
   \   000000F8   0x9003             STR      R0,[SP, #+12]
   1274                  command.BLOCKSIZE = 4;
   \   000000FA   0x2004             MOVS     R0,#+4
   \   000000FC   0x9004             STR      R0,[SP, #+16]
   1275                  if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   000000FE   0xA901             ADD      R1,SP,#+4
   \   00000100   0x2002             MOVS     R0,#+2
   \   00000102   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000106   0x4680             MOV      R8,R0
   \   00000108   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000010C   0xD002             BEQ.N    ??LPLD_SDHC_WriteBlocks_14
   1276                  {
   1277                      return (SDHCRES)result;
   \   0000010E   0x4640             MOV      R0,R8
   \   00000110   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000112   0xE02A             B.N      ??LPLD_SDHC_WriteBlocks_4
   1278                  }
   1279                  
   1280                  if (4 != (result=LPLD_SDHC_Read (tmp, 4)))
   \                     ??LPLD_SDHC_WriteBlocks_14: (+1)
   \   00000114   0x2104             MOVS     R1,#+4
   \   00000116   0xA800             ADD      R0,SP,#+0
   \   00000118   0x.... 0x....      BL       LPLD_SDHC_Read
   \   0000011C   0x4680             MOV      R8,R0
   \   0000011E   0x2804             CMP      R0,#+4
   \   00000120   0xD002             BEQ.N    ??LPLD_SDHC_WriteBlocks_15
   1281                  {
   1282                      return (SDHCRES)result;
   \   00000122   0x4640             MOV      R0,R8
   \   00000124   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000126   0xE020             B.N      ??LPLD_SDHC_WriteBlocks_4
   1283                      
   1284                  }
   1285          
   1286                  if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_FLUSH_OUTPUT, NULL)))
   \                     ??LPLD_SDHC_WriteBlocks_15: (+1)
   \   00000128   0x2100             MOVS     R1,#+0
   \   0000012A   0x2093             MOVS     R0,#+147
   \   0000012C   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000130   0x4680             MOV      R8,R0
   \   00000132   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000136   0xD002             BEQ.N    ??LPLD_SDHC_WriteBlocks_16
   1287                  {
   1288                      return (SDHCRES)result;
   \   00000138   0x4640             MOV      R0,R8
   \   0000013A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000013C   0xE015             B.N      ??LPLD_SDHC_WriteBlocks_4
   1289                  }
   1290          
   1291                  count = (tmp[0] << 24) | (tmp[1] << 16) | (tmp[2] << 8) | tmp[3];
   \                     ??LPLD_SDHC_WriteBlocks_16: (+1)
   \   0000013E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000142   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   00000146   0x0409             LSLS     R1,R1,#+16
   \   00000148   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   0000014C   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   00000150   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000154   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   00000158   0x4308             ORRS     R0,R1,R0
   \   0000015A   0x0004             MOVS     R4,R0
   1292                  if ((cnt < 0) || (cnt > count))
   \   0000015C   0x2F00             CMP      R7,#+0
   \   0000015E   0xD401             BMI.N    ??LPLD_SDHC_WriteBlocks_17
   \   00000160   0x42BC             CMP      R4,R7
   \   00000162   0xD201             BCS.N    ??LPLD_SDHC_WriteBlocks_12
   1293                      return SDHCRES_ERROR;
   \                     ??LPLD_SDHC_WriteBlocks_17: (+1)
   \   00000164   0x2001             MOVS     R0,#+1
   \   00000166   0xE000             B.N      ??LPLD_SDHC_WriteBlocks_4
   1294              }
   1295              
   1296              return SDHCRES_OK;
   \                     ??LPLD_SDHC_WriteBlocks_12: (+1)
   \   00000168   0x2000             MOVS     R0,#+0
   \                     ??LPLD_SDHC_WriteBlocks_4: (+1)
   \   0000016A   0xB00A             ADD      SP,SP,#+40
   \   0000016C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1297          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x4004D000         DC32     0x4004d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x4004D004         DC32     0x4004d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x4004D008         DC32     0x4004d008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x4004D00C         DC32     0x4004d00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x4004D010         DC32     0x4004d010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x4004D014         DC32     0x4004d014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x40048030         DC32     0x40048030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x400B102C         DC32     0x400b102c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x400B1024         DC32     0x400b1024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x01008000         DC32     0x1008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x400B10C0         DC32     0x400b10c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   0x400B1004         DC32     0x400b1004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \   00000000   0x00010002         DC32     0x10002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_13:
   \   00000000   0x400B1044         DC32     0x400b1044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_14:
   \   00000000   0x007F00B3         DC32     0x7f00b3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_15:
   \   00000000   0x400B1034         DC32     0x400b1034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x400B1030         DC32     0x400b1030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     sdcard_ptr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x400B1028         DC32     0x400b1028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x400B1008         DC32     0x400b1008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x400B1000         DC32     0x400b1000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x400B100C         DC32     0x400b100c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x000E0001         DC32     0xe0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x400B1010         DC32     0x400b1010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x400B1014         DC32     0x400b1014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x400B1018         DC32     0x400b1018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x400B101C         DC32     0x400b101c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x00061A80         DC32     0x61a80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     g_core_clock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x081A0000         DC32     0x81a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x05020000         DC32     0x5020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x371A0000         DC32     0x371a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x40300000         DC32     0x40300000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x27020000         DC32     0x27020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x29020000         DC32     0x29020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x017D7840         DC32     0x17d7840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x400B1020         DC32     0x400b1020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x02090000         DC32     0x2090000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x031A0000         DC32     0x31a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x09090000         DC32     0x9090000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0x071B0000         DC32     0x71b0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \   00000000   0x101A0000         DC32     0x101a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \   00000000   0x061A0000         DC32     0x61a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_13:
   \   00000000   0x........         DC32     sdcard_ptr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_14:
   \   00000000   0x121A0034         DC32     0x121a0034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_15:
   \   00000000   0x111A0010         DC32     0x111a0010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_16:
   \   00000000   0x191A0024         DC32     0x191a0024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_17:
   \   00000000   0x181A0000         DC32     0x181a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_18:
   \   00000000   0x0D1A0000         DC32     0xd1a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_19:
   \   00000000   0xFFD98008         DC32     0xffd98008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_20:
   \   00000000   0x161A0010         DC32     0x161a0010

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      72   LPLD_SDHC_IOC
        72   -> LPLD_SDHC_Init
        72   -> LPLD_SDHC_InitGPIO
        72   -> LPLD_SDHC_IsRunning
        72   -> LPLD_SDHC_SendCommand
        72   -> LPLD_SDHC_SetBaudrate
        72   -> LPLD_SDHC_WaitStatus
      16   LPLD_SDHC_Init
        16   -> LPLD_SDHC_InitGPIO
        16   -> LPLD_SDHC_SetBaudrate
      64   LPLD_SDHC_InitCard
        64   -> LPLD_SDHC_IOC
        64   -> malloc
       0   LPLD_SDHC_InitGPIO
       0   LPLD_SDHC_IsRunning
       8   LPLD_SDHC_Read
      56   LPLD_SDHC_ReadBlocks
        56   -> LPLD_SDHC_IOC
        56   -> LPLD_SDHC_Read
      16   LPLD_SDHC_SendCommand
        16   -> LPLD_SDHC_WaitStatus
      20   LPLD_SDHC_SetBaudrate
       0   LPLD_SDHC_WaitStatus
      12   LPLD_SDHC_Write
      64   LPLD_SDHC_WriteBlocks
        64   -> LPLD_SDHC_IOC
        64   -> LPLD_SDHC_Read
        64   -> LPLD_SDHC_Write


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_16
       4  ??DataTable11_17
       4  ??DataTable11_18
       4  ??DataTable11_19
       4  ??DataTable11_2
       4  ??DataTable11_20
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_14
       4  ??DataTable8_15
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
    1614  LPLD_SDHC_IOC
     204  LPLD_SDHC_Init
     592  LPLD_SDHC_InitCard
      88  LPLD_SDHC_InitGPIO
      24  LPLD_SDHC_IsRunning
     294  LPLD_SDHC_Read
     142  LPLD_SDHC_ReadBlocks
     324  LPLD_SDHC_SendCommand
     200  LPLD_SDHC_SetBaudrate
      18  LPLD_SDHC_WaitStatus
     274  LPLD_SDHC_Write
     368  LPLD_SDHC_WriteBlocks
       4  sdcard_ptr

 
     4 bytes in section .bss
 4 346 bytes in section .text
 
 4 346 bytes of CODE memory
     4 bytes of DATA memory

Errors: none
Warnings: none
