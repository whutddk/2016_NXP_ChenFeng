###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        08/Aug/2016  13:02:54
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\app\SENSOR\i2c.c
#    Command line =  
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\app\SENSOR\i2c.c" -D LPLD_K60 -lCN
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\FLASH\List\" -lB
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\FLASH\List\" -o
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\FLASH\Obj\" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\..\app\" -I
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\..\app\BSP\" -I
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\..\app\ITAC\" -I
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\..\app\CTL\" -I
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\..\app\MAIN\" -I
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\..\app\SENSOR\" -I
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\..\..\..\lib\CPU\" -I
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\..\..\..\lib\common\" -I
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\..\..\..\lib\LPLD\" -I
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\..\..\..\lib\LPLD\HW\" -I
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\..\..\..\lib\LPLD\DEV\" -I
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\..\..\..\lib\uCOS-II\Ports\" -I
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\..\..\..\lib\uCOS-II\Source\" -I
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\..\..\..\lib\FatFs\" -I
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\..\..\..\lib\FatFs\option\" -I
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\..\..\..\lib\USB\common\" -I
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\..\..\..\lib\USB\driver\" -I
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\..\..\..\lib\USB\descriptor\" -I
#        "C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\..\..\..\lib\USB\class\" -On -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.0\arm\CMSIS\Include\" -D
#        ARM_MATH_CM4
#    List file    =  
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\FLASH\List\i2c.lst
#    Object file  =  
#        C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid)
#        冲击华南赛 1车\iar\FLASH\Obj\i2c.o
#
###############################################################################

C:\百度云同步盘\比赛代码\LPLD_OSKinetis_V3\launch\NXP_(golden_cyprinoid) 冲击华南赛 1车\app\SENSOR\i2c.c
      1          //I2C 通用C文件 IO模拟版
      2          //DDK
      3          //2015 5 4
      4          
      5          
      6          #include "include.h"
      7          #include "i2c.h"

   \                                 In section .text, align 2, keep-with-next
      8          void I2Cdelay_1us(uint8 i)
      9          {
   \                     I2Cdelay_1us: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     10            LPLD_SYSTICK_DelayUs(i);
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       LPLD_SYSTICK_DelayUs
     11          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
     12          

   \                                 In section .text, align 2, keep-with-next
     13          void I2C_CLK_INIT()
     14          {
   \                     I2C_CLK_INIT: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
     15            GPIO_InitTypeDef gpio_inittype;
     16            gpio_inittype.GPIO_PTx = I2C_CLK_PT;
   \   00000004   0x....             LDR.N    R0,??DataTable9  ;; 0x400ff080
   \   00000006   0x9001             STR      R0,[SP, #+4]
     17            gpio_inittype.GPIO_Pins = I2C_CLK_PIN;
   \   00000008   0xF44F 0x6080      MOV      R0,#+1024
   \   0000000C   0x9002             STR      R0,[SP, #+8]
     18            gpio_inittype.GPIO_Dir = DIR_OUTPUT;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF88D 0x0010      STRB     R0,[SP, #+16]
     19            gpio_inittype.GPIO_Output = OUTPUT_H;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF88D 0x0011      STRB     R0,[SP, #+17]
     20            gpio_inittype.GPIO_PinControl = IRQC_DIS;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x9003             STR      R0,[SP, #+12]
     21            LPLD_GPIO_Init(gpio_inittype);
   \   0000001E   0xA901             ADD      R1,SP,#+4
   \   00000020   0xB084             SUB      SP,SP,#+16
   \   00000022   0x4668             MOV      R0,SP
   \   00000024   0x2214             MOVS     R2,#+20
   \   00000026   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000002A   0xBC0F             POP      {R0-R3}
   \   0000002C   0x.... 0x....      BL       LPLD_GPIO_Init
     22          }
   \   00000030   0xB007             ADD      SP,SP,#+28
   \   00000032   0xBD00             POP      {PC}             ;; return
     23          

   \                                 In section .text, align 2, keep-with-next
     24          void I2C_DAT_IN()
     25          {
   \                     I2C_DAT_IN: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
     26            GPIO_InitTypeDef gpio_inittype;
     27            gpio_inittype.GPIO_PTx = I2C_DAT_PT;
   \   00000004   0x....             LDR.N    R0,??DataTable9  ;; 0x400ff080
   \   00000006   0x9001             STR      R0,[SP, #+4]
     28            gpio_inittype.GPIO_Pins = I2C_DAT_PIN;
   \   00000008   0xF44F 0x6000      MOV      R0,#+2048
   \   0000000C   0x9002             STR      R0,[SP, #+8]
     29            gpio_inittype.GPIO_Dir = DIR_INPUT;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF88D 0x0010      STRB     R0,[SP, #+16]
     30            gpio_inittype.GPIO_Output = OUTPUT_H;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF88D 0x0011      STRB     R0,[SP, #+17]
     31            gpio_inittype.GPIO_PinControl = IRQC_DIS;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x9003             STR      R0,[SP, #+12]
     32            LPLD_GPIO_Init(gpio_inittype);
   \   0000001E   0xA901             ADD      R1,SP,#+4
   \   00000020   0xB084             SUB      SP,SP,#+16
   \   00000022   0x4668             MOV      R0,SP
   \   00000024   0x2214             MOVS     R2,#+20
   \   00000026   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000002A   0xBC0F             POP      {R0-R3}
   \   0000002C   0x.... 0x....      BL       LPLD_GPIO_Init
     33          }
   \   00000030   0xB007             ADD      SP,SP,#+28
   \   00000032   0xBD00             POP      {PC}             ;; return
     34          

   \                                 In section .text, align 2, keep-with-next
     35          void I2C_DAT_OUT()
     36          {
   \                     I2C_DAT_OUT: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
     37            GPIO_InitTypeDef gpio_inittype;
     38            gpio_inittype.GPIO_PTx = I2C_DAT_PT;
   \   00000004   0x....             LDR.N    R0,??DataTable9  ;; 0x400ff080
   \   00000006   0x9001             STR      R0,[SP, #+4]
     39            gpio_inittype.GPIO_Pins = I2C_DAT_PIN;
   \   00000008   0xF44F 0x6000      MOV      R0,#+2048
   \   0000000C   0x9002             STR      R0,[SP, #+8]
     40            gpio_inittype.GPIO_Dir = DIR_INPUT;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF88D 0x0010      STRB     R0,[SP, #+16]
     41            gpio_inittype.GPIO_Output = OUTPUT_H;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF88D 0x0011      STRB     R0,[SP, #+17]
     42            gpio_inittype.GPIO_PinControl = IRQC_DIS;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x9003             STR      R0,[SP, #+12]
     43            LPLD_GPIO_Init(gpio_inittype);
   \   0000001E   0xA901             ADD      R1,SP,#+4
   \   00000020   0xB084             SUB      SP,SP,#+16
   \   00000022   0x4668             MOV      R0,SP
   \   00000024   0x2214             MOVS     R2,#+20
   \   00000026   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000002A   0xBC0F             POP      {R0-R3}
   \   0000002C   0x.... 0x....      BL       LPLD_GPIO_Init
     44          }
   \   00000030   0xB007             ADD      SP,SP,#+28
   \   00000032   0xBD00             POP      {PC}             ;; return
     45          
     46          //**************************************
     47          //I2C起始信号
     48          //**************************************
     49          //--------------------------------------------------------------------------------------------------
     50          // 函数名称： iic_start()
     51          // 函数功能： 启动I2C总线子程序
     52          //--------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     53          void I2C_start(void)
     54          {    
   \                     I2C_start: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     55            I2CDDRA = 1;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x....             LDR.N    R1,??DataTable9_1  ;; 0x43fe12ac
   \   00000006   0x6008             STR      R0,[R1, #+0]
     56            I2CSDA = 1;  
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x....             LDR.N    R1,??DataTable9_2  ;; 0x43fe102c
   \   0000000C   0x6008             STR      R0,[R1, #+0]
     57            I2Cdelay_1us(2);
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0x.... 0x....      BL       I2Cdelay_1us
     58            I2CCLK = 1;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x....             LDR.N    R1,??DataTable9_3  ;; 0x43fe1028
   \   00000018   0x6008             STR      R0,[R1, #+0]
     59            I2Cdelay_1us(2);      // 延时5us 
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x.... 0x....      BL       I2Cdelay_1us
     60            I2CSDA = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR.N    R1,??DataTable9_2  ;; 0x43fe102c
   \   00000024   0x6008             STR      R0,[R1, #+0]
     61            I2Cdelay_1us(2);  
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0x.... 0x....      BL       I2Cdelay_1us
     62            I2CCLK = 0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x....             LDR.N    R1,??DataTable9_3  ;; 0x43fe1028
   \   00000030   0x6008             STR      R0,[R1, #+0]
     63            I2Cdelay_1us(2);
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x.... 0x....      BL       I2Cdelay_1us
     64          }
   \   00000038   0xBD01             POP      {R0,PC}          ;; return
     65          
     66          
     67          //**************************************
     68          //I2C停止信号
     69          //**************************************
     70          //--------------------------------------------------------------------------------------------------
     71          // 函数名称： iic_stop()
     72          // 函数功能： 停止I2C总线数据传送子程序
     73          //--------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     74          void I2C_stop(void)
     75          { 
   \                     I2C_stop: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     76            I2CDDRA = 1;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x....             LDR.N    R1,??DataTable9_1  ;; 0x43fe12ac
   \   00000006   0x6008             STR      R0,[R1, #+0]
     77            I2CSDA = 0;   	   //时钟保持高，数据线从低到高一次跳变，I2C通信停止
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             LDR.N    R1,??DataTable9_2  ;; 0x43fe102c
   \   0000000C   0x6008             STR      R0,[R1, #+0]
     78            I2Cdelay_1us(2);      // 延时1us 
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0x.... 0x....      BL       I2Cdelay_1us
     79            I2CCLK = 1;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x....             LDR.N    R1,??DataTable9_3  ;; 0x43fe1028
   \   00000018   0x6008             STR      R0,[R1, #+0]
     80            I2Cdelay_1us(2);
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x.... 0x....      BL       I2Cdelay_1us
     81            I2CSDA = 1;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x....             LDR.N    R1,??DataTable9_2  ;; 0x43fe102c
   \   00000024   0x6008             STR      R0,[R1, #+0]
     82            I2Cdelay_1us(2);
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0x.... 0x....      BL       I2Cdelay_1us
     83            //BFCLK = 0;
     84            //delay(2);
     85          }
   \   0000002C   0xBD01             POP      {R0,PC}          ;; return
     86          //--------------------------------------------------------------------------------------------------
     87          // 函数名称： check_ACK
     88          // 函数功能： 主机应答位检查子程序，迫使数据传输过程结束
     89          //--------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     90          uint8 I2Ccheck_ACK(void)
     91          { 
   \                     I2Ccheck_ACK: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     92            uint8 check ;
     93          
     94            I2CCLK = 1;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x....             LDR.N    R1,??DataTable9_3  ;; 0x43fe1028
   \   00000006   0x6008             STR      R0,[R1, #+0]
     95           I2Cdelay_1us(2);
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x.... 0x....      BL       I2Cdelay_1us
     96            check = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x0004             MOVS     R4,R0
     97            I2CDDRA = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x....             LDR.N    R1,??DataTable9_1  ;; 0x43fe12ac
   \   00000016   0x6008             STR      R0,[R1, #+0]
     98            if(I2CSDAI == 1)    // 若BFSDA=1 表明非应答，置位非应答标志F0
   \   00000018   0x....             LDR.N    R0,??DataTable9_4  ;; 0x43fe122c
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD101             BNE.N    ??I2Ccheck_ACK_0
     99            check = 1;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x0004             MOVS     R4,R0
    100            I2Cdelay_1us(2);      // 延时1us 
   \                     ??I2Ccheck_ACK_0: (+1)
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0x.... 0x....      BL       I2Cdelay_1us
    101            I2CCLK = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x....             LDR.N    R1,??DataTable9_3  ;; 0x43fe1028
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    102            //gpio_init (PORTE , 12, GPO,HIGH);      
    103            I2CDDRA = 1 ;         //
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x....             LDR.N    R1,??DataTable9_1  ;; 0x43fe12ac
   \   00000034   0x6008             STR      R0,[R1, #+0]
    104            //BFSDA = 1 ;
    105            return  check ;
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    106          }
    107          //**************************************
    108          //I2C接收应答信号
    109          //**************************************
    110          //--------------------------------------------------------------------------------------------------
    111          // 函数名称： slave_ACK
    112          // 函数功能： 从机发送应答位子程序
    113          //--------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    114          void I2Cslave_ACK(void)
    115          {
   \                     I2Cslave_ACK: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    116            I2CDDRA = 1;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x....             LDR.N    R1,??DataTable9_1  ;; 0x43fe12ac
   \   00000006   0x6008             STR      R0,[R1, #+0]
    117            I2CSDA = 1; 
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x....             LDR.N    R1,??DataTable9_2  ;; 0x43fe102c
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    118            I2Cdelay_1us(2);      // 延时1us 
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0x.... 0x....      BL       I2Cdelay_1us
    119            I2CCLK = 1;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x....             LDR.N    R1,??DataTable9_3  ;; 0x43fe1028
   \   00000018   0x6008             STR      R0,[R1, #+0]
    120            I2Cdelay_1us(2);			
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x.... 0x....      BL       I2Cdelay_1us
    121            
    122            I2CCLK = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR.N    R1,??DataTable9_3  ;; 0x43fe1028
   \   00000024   0x6008             STR      R0,[R1, #+0]
    123            I2Cdelay_1us(2);
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0x.... 0x....      BL       I2Cdelay_1us
    124          }
   \   0000002C   0xBD01             POP      {R0,PC}          ;; return
    125          
    126          //--------------------------------------------------------------------------------------------------
    127          // 函数名称： slave_NOACK
    128          // 函数功能： 从机发送非应答位子程序，迫使数据传输过程结束
    129          //--------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    130          void I2Cslave_NOACK(void)
    131          { 
   \                     I2Cslave_NOACK: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    132            I2CDDRA = 1;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x....             LDR.N    R1,??DataTable9_1  ;; 0x43fe12ac
   \   00000006   0x6008             STR      R0,[R1, #+0]
    133            I2CSDA = 0;  
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             LDR.N    R1,??DataTable9_2  ;; 0x43fe102c
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    134            I2Cdelay_1us(2);      // 延时1us 
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0x.... 0x....      BL       I2Cdelay_1us
    135            I2CCLK = 1;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x....             LDR.N    R1,??DataTable9_3  ;; 0x43fe1028
   \   00000018   0x6008             STR      R0,[R1, #+0]
    136            I2Cdelay_1us(2);
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x.... 0x....      BL       I2Cdelay_1us
    137            //BFSDA = 0;
    138            //delay(5);      // 延时1us 
    139            I2CCLK = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR.N    R1,??DataTable9_3  ;; 0x43fe1028
   \   00000024   0x6008             STR      R0,[R1, #+0]
    140          }
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
    141          //--------------------------------------------------------------------------------------------------
    142          // 函数名称： IICSendByte
    143          // 入口参数： ch
    144          // 函数功能： 发送一个字节
    145          //--------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    146          void I2CSendByte(uint8 ch)
    147          { 
   \                     I2CSendByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    148            uint8_t i;     // 向BFSDA上发送一位数据字节，共八位
    149            for (i=0; i<8; i++)         //8位计数器
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0005             MOVS     R5,R0
   \                     ??I2CSendByte_0: (+1)
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0x2D08             CMP      R5,#+8
   \   0000000C   0xDA16             BGE.N    ??I2CSendByte_1
    150            {
    151                            //移出数据的最高位
    152              I2CDDRA = 1;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x....             LDR.N    R1,??DataTable9_1  ;; 0x43fe12ac
   \   00000012   0x6008             STR      R0,[R1, #+0]
    153              I2CSDA = (( ch & 0x80 ) >> 7);               //送数据口
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x09E0             LSRS     R0,R4,#+7
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x....             LDR.N    R1,??DataTable9_2  ;; 0x43fe102c
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    154              I2CCLK = 1;                //拉高时钟线
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x....             LDR.N    R1,??DataTable9_3  ;; 0x43fe1028
   \   00000022   0x6008             STR      R0,[R1, #+0]
    155              I2Cdelay_1us(2);             //延时
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0x.... 0x....      BL       I2Cdelay_1us
    156              I2CCLK = 0;                //拉低时钟线
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x....             LDR.N    R1,??DataTable9_3  ;; 0x43fe1028
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    157              I2Cdelay_1us(2);             //延时
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0x.... 0x....      BL       I2Cdelay_1us
    158              ch <<= 1;
   \   00000036   0x0064             LSLS     R4,R4,#+1
    159            }
   \   00000038   0x1C6D             ADDS     R5,R5,#+1
   \   0000003A   0xE7E5             B.N      ??I2CSendByte_0
    160            I2Ccheck_ACK();
   \                     ??I2CSendByte_1: (+1)
   \   0000003C   0x.... 0x....      BL       I2Ccheck_ACK
    161          }
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    162          //--------------------------------------------------------------------------------------------------
    163          // 函数名称： IICreceiveByte
    164          // 返回接收的数据
    165          // 函数功能： 接收一字节子程序
    166          //--------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    167          uint8 I2CreceiveByte(void)
    168          {
   \                     I2CreceiveByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    169            uint8 n=8;    // 从BFSDA线上读取一上数据字节，共八位
   \   00000002   0x2508             MOVS     R5,#+8
    170            uint8 tdata = 0;
   \   00000004   0x2400             MOVS     R4,#+0
    171            while(n--)
   \                     ??I2CreceiveByte_0: (+1)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x1E45             SUBS     R5,R0,#+1
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD028             BEQ.N    ??I2CreceiveByte_1
    172            {      
    173              I2CDDRA = 1 ;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x....             LDR.N    R1,??DataTable9_1  ;; 0x43fe12ac
   \   00000014   0x6008             STR      R0,[R1, #+0]
    174              I2CSDA = 1;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x....             LDR.N    R1,??DataTable9_2  ;; 0x43fe102c
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    175              I2Cdelay_1us(2);
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x.... 0x....      BL       I2Cdelay_1us
    176              I2CCLK=0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR.N    R1,??DataTable9_3  ;; 0x43fe1028
   \   00000026   0x6008             STR      R0,[R1, #+0]
    177              I2Cdelay_1us(2);
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0x.... 0x....      BL       I2Cdelay_1us
    178              I2CCLK = 1;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x....             LDR.N    R1,??DataTable9_3  ;; 0x43fe1028
   \   00000032   0x6008             STR      R0,[R1, #+0]
    179              I2Cdelay_1us(2);
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0x.... 0x....      BL       I2Cdelay_1us
    180              
    181              I2CDDRA = 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x....             LDR.N    R1,??DataTable9_1  ;; 0x43fe12ac
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    182              
    183              tdata = tdata<<1;    // 左移一位，或_crol_(temp,1)
   \   00000040   0x0064             LSLS     R4,R4,#+1
    184              if(I2CSDAI == 1)
   \   00000042   0x....             LDR.N    R0,??DataTable9_4  ;; 0x43fe122c
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x2801             CMP      R0,#+1
   \   00000048   0xD102             BNE.N    ??I2CreceiveByte_2
    185              tdata = tdata|0x01;    // 若接收到的位为1，则数据的最后一位置1
   \   0000004A   0xF054 0x0401      ORRS     R4,R4,#0x1
   \   0000004E   0xE001             B.N      ??I2CreceiveByte_3
    186              else 
    187              tdata = tdata&0xfe;    // 否则数据的最后一位置0
   \                     ??I2CreceiveByte_2: (+1)
   \   00000050   0xF014 0x04FE      ANDS     R4,R4,#0xFE
    188              I2CCLK=0;
   \                     ??I2CreceiveByte_3: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x....             LDR.N    R1,??DataTable9_3  ;; 0x43fe1028
   \   00000058   0x6008             STR      R0,[R1, #+0]
    189              I2CDDRA = 1 ;
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x....             LDR.N    R1,??DataTable9_1  ;; 0x43fe12ac
   \   0000005E   0x6008             STR      R0,[R1, #+0]
   \   00000060   0xE7D1             B.N      ??I2CreceiveByte_0
    190            }
    191            return(tdata);
   \                     ??I2CreceiveByte_1: (+1)
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    192          }
    193          

   \                                 In section .text, align 2, keep-with-next
    194          void LDC_SEND(uint8 addr,uint16 dat)
    195          {
   \                     LDC_SEND: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    196            I2C_start();
   \   00000006   0x.... 0x....      BL       I2C_start
    197            I2CSendByte((0x2A <<1) );
   \   0000000A   0x2054             MOVS     R0,#+84
   \   0000000C   0x.... 0x....      BL       I2CSendByte
    198            I2CSendByte(addr);
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x.... 0x....      BL       I2CSendByte
    199            
    200            I2CSendByte((uint8) ((dat & 0xff00)>>8 ));
   \   00000018   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001A   0x0A28             LSRS     R0,R5,#+8
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x.... 0x....      BL       I2CSendByte
    201            I2CSendByte((uint8) (dat & 0xff));
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x.... 0x....      BL       I2CSendByte
    202            I2C_stop();
   \   0000002A   0x.... 0x....      BL       I2C_stop
    203          }
   \   0000002E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    204          

   \                                 In section .text, align 2, keep-with-next
    205          uint16 LDC_READ(uint8 addr)
    206          {
   \                     LDC_READ: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    207            uint16 temp = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    208            I2C_start();
   \   00000006   0x.... 0x....      BL       I2C_start
    209            I2CSendByte((0x2A << 1));
   \   0000000A   0x2054             MOVS     R0,#+84
   \   0000000C   0x.... 0x....      BL       I2CSendByte
    210            I2CSendByte(addr);
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x.... 0x....      BL       I2CSendByte
    211            
    212            I2C_start();
   \   00000018   0x.... 0x....      BL       I2C_start
    213            I2CSendByte((0x2A << 1)| 0x01);
   \   0000001C   0x2055             MOVS     R0,#+85
   \   0000001E   0x.... 0x....      BL       I2CSendByte
    214            temp = I2CreceiveByte();
   \   00000022   0x.... 0x....      BL       I2CreceiveByte
   \   00000026   0x0005             MOVS     R5,R0
    215            temp = temp << 8;
   \   00000028   0x022D             LSLS     R5,R5,#+8
    216            I2Cslave_NOACK();
   \   0000002A   0x.... 0x....      BL       I2Cslave_NOACK
    217            temp |= I2CreceiveByte();
   \   0000002E   0x.... 0x....      BL       I2CreceiveByte
   \   00000032   0x4328             ORRS     R0,R0,R5
   \   00000034   0x0005             MOVS     R5,R0
    218            I2Cslave_ACK();
   \   00000036   0x.... 0x....      BL       I2Cslave_ACK
    219            I2C_stop();
   \   0000003A   0x.... 0x....      BL       I2C_stop
    220            
    221            return temp;
   \   0000003E   0x0028             MOVS     R0,R5
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    222          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x400FF080         DC32     0x400ff080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x43FE12AC         DC32     0x43fe12ac

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x43FE102C         DC32     0x43fe102c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x43FE1028         DC32     0x43fe1028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x43FE122C         DC32     0x43fe122c
    223          
    224          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   I2CSendByte
        16   -> I2Ccheck_ACK
        16   -> I2Cdelay_1us
      48   I2C_CLK_INIT
        32   -> LPLD_GPIO_Init
        48   -> __aeabi_memcpy4
      48   I2C_DAT_IN
        32   -> LPLD_GPIO_Init
        48   -> __aeabi_memcpy4
      48   I2C_DAT_OUT
        32   -> LPLD_GPIO_Init
        48   -> __aeabi_memcpy4
       8   I2C_start
         8   -> I2Cdelay_1us
       8   I2C_stop
         8   -> I2Cdelay_1us
       8   I2Ccheck_ACK
         8   -> I2Cdelay_1us
       8   I2Cdelay_1us
         8   -> LPLD_SYSTICK_DelayUs
      16   I2CreceiveByte
        16   -> I2Cdelay_1us
       8   I2Cslave_ACK
         8   -> I2Cdelay_1us
       8   I2Cslave_NOACK
         8   -> I2Cdelay_1us
      16   LDC_READ
        16   -> I2CSendByte
        16   -> I2C_start
        16   -> I2C_stop
        16   -> I2CreceiveByte
        16   -> I2Cslave_ACK
        16   -> I2Cslave_NOACK
      16   LDC_SEND
        16   -> I2CSendByte
        16   -> I2C_start
        16   -> I2C_stop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
      66  I2CSendByte
      52  I2C_CLK_INIT
      52  I2C_DAT_IN
      52  I2C_DAT_OUT
      58  I2C_start
      46  I2C_stop
      60  I2Ccheck_ACK
      14  I2Cdelay_1us
     104  I2CreceiveByte
      46  I2Cslave_ACK
      40  I2Cslave_NOACK
      68  LDC_READ
      48  LDC_SEND

 
 726 bytes in section .text
 
 726 bytes of CODE memory

Errors: none
Warnings: none
